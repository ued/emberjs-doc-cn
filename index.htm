<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Ember.js - 中文文档 by 姬小光 @diao.it</title>
    <meta charset="utf-8">
    <link href="./assets/site.css" media="screen" rel="stylesheet" type="text/css">
    <link href="./assets/highlight.css" media="screen" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="./assets/jquery.min.js"></script>
    <script type="text/javascript" src="./assets/jquery.bxSlider.min.js"></script>

    <script type="text/javascript">
      $(function() {
        $('#logo').on('click', function(evt) {
          if (evt.shiftKey) {
            $('#content-wrapper').toggleClass('grid');
            return false;
          }
        });

        var backToTop = $('#back-to-top');
        var doc = $(document);
        var offset = backToTop.offset();
        var marginTop = 90;
        var showing = false;

        if (backToTop.length) {
          backToTop.on('click', function(evt) {
            $('html,body').animate({scrollTop: 0}, 200);
            return false;
          });

          doc.on('scroll', function() {
            if (!showing && doc.scrollTop() > offset.top+200) {
              showing = true;
              backToTop.css({
                opacity: 1,
                position: 'fixed',
                top: 20,
                left: offset.left
              });
            } else if (showing && doc.scrollTop() <= offset.top+200) {
              showing = false;
              backToTop.css({
                opacity: 0
              });
            }
          });
        }

        $('.bx-wrapper, .bx-window').width(940);
      });
    </script>


  </head>

  <body>
  <div id="header">
      <div id="wrapper">
        <a id="logo" href="http://emberjs.com/">&nbsp;</a>
        <ul id="nav">
          <li><a href="http://emberjs.com/about">关于</a></li>
          <li class="active"><a href="http://emberjs.com/documentation">文档</a></li>
          <li><a href="http://emberjs.com/guides">指南</a></li>
          <li><a href="http://docs.emberjs.com/">API</a></li>
          <li><a href="http://emberjs.com/community">社区</a></li>
          <li><a href="http://emberjs.com/blog">博客</a></li>
        </ul>
        <div id="github">
          <a href="https://github.com/emberjs/ember.js"><img src="./assets/fork-us.png">Fork Us!</a>
        </div>
      </div>
    </div>

    <div id="content-wrapper">


        <div id="sidebar">
        <ol>
            <li class="level-2">引言</li>
            <li class="level-3"><a href="http://emberjs.com/documentation/#toc_what-is-ember-js">Ember.js 是什么?</a></li>
            <li class="level-3"><a href="./index_files/index.htm"> Ember.js 有何不同?</a></li>
            <li class="level-3"><a href="#toc_ember-js-at-a-glance">Ember.js 概览</a></li><li class="level-2"><a href="#toc_getting-started">入门</a></li><li class="level-2"><a href="#toc_the-ember-object-model">Ember对象模型</a></li>
            <li class="level-3"><a href="#toc_subclassing-classes">类的子类</a></li>
            <li class="level-3"><a href="#toc_reopening-classes-and-instances">重新打开类和实例</a></li>
            <li class="level-3"><a href="#toc_computed-properties-getters">计算属性 （Getters）</a></li>
            <li class="level-3"><a href="#toc_computed-properties-setters">计算属性 （Setters）</a></li>
            <li class="level-3"><a href="#toc_observers">观察者</a></li>
            <li class="level-3"><a href="#toc_bindings">绑定</a></li>
            <li class="level-3"><a href="#toc_what-do-i-use-when">何时用何物？</a></li>
            <li class="level-2"><a href="#toc_creating-a-namespace">创建命名空间</a></li>
            <li class="level-2"><a href="#toc_describing-your-ui-with-handlebars">使用HANDLEBARS描述你的UI</a></li>
            <li class="level-3"><a href="#toc_handlebars">Handlebars</a></li>
            <li class="level-3"><a href="#toc_ember-view">Ember.View</a></li>
            <li class="level-3"><a href="#toc_handlebars-basics">使用HANDLEBARS描述你的UI</a></li>
            <li class="level-3"><a href="#toc_if-else-and-unless">{{#if}}，{{else}}，和{{#unless}}</a></li>
            <li class="level-3"><a href="#toc_with">{{#with}}</a></li>
            <li class="level-3"><a href="#toc_binding-element-attributes-with-bindattr">使用{{bindAttr}}绑定元素属性</a></li>
            <li class="level-3"><a href="#toc_binding-class-names-with-bindattr">使用{{bindAttr}}绑定类名</a></li>
            <li class="level-3"><a href="#toc_handling-events-with-action">使用{{action}}处理事件</a></li>
            <li class="level-3"><a href="#toc_building-a-view-hierarchy">创建视图的层次结构</a></li>
            <li class="level-3"><a href="#toc_view">{{view}}</a></li>
            <li class="level-3"><a href="#toc_setting-child-view-templates">设置子视图模板</a></li>
            <li class="level-3"><a href="#toc_setting-up-bindings">设置绑定</a></li>
            <li class="level-3"><a href="#toc_modifying-a-view-s-html">修改视图的HTML</a></li>
            <li class="level-3"><a href="#toc_displaying-a-list-of-items">显示一个列表的项目</a></li>
            <li class="level-3"><a href="#toc_writing-custom-helpers">编写自定义助手</a></li>
            <li class="level-3"><a href="#toc_included-views">已包含的视图</a></li>
            <li class="level-2"><a href="#toc_views-in-depth">深入探讨视图</a></li>
            <li class="level-3"><a href="#toc_handling-events">处理事件</a></li>
            <li class="level-3"><a href="#toc_manually-managed-views-with-ember-containerview">使用Ember.ContainerView手动管理视图</a></li>
            <li class="level-3"><a href="#toc_render-pipeline">渲染管线（Render Pipeline）</a></li>
            <li class="level-3"><a href="#toc_customizing-the-html-element">自定义HTML元素</a></li>
            <li class="level-3"><a href="#toc_attribute-bindings-on-a-view">视图的属性绑定</a></li>
            <li class="level-2"><a href="#toc_the-ember-enumerable-api">Ember的枚举（Enumerable）API</a></li>
            <li class="level-3"><a href="#toc_what-are-enumerables">什么是枚举类型？</a></li>
            <li class="level-3"><a href="#toc_enumerables-in-ember">Ember中的枚举类型</a></li>
            <li class="level-3"><a href="#toc_the-enumerable-interface">枚举接口</a></li>
        </ol>

          <div id="back-to-top"><a href="#">↑返回顶部</a></div>
        </div>

      <div id="content" class="has-sidebar">

      <div class="tip" style="color:#999;"><a href="https://diao.it" target="_blank" title="姬小光">译者</a>注: 译文时间匆忙难免慌张，为方便大家理解原文并指正错误，故保留英文原文，可对照阅读。<br>欢迎 <a href="https://github.com/ued/emberjs-doc-cn" target="_blank">FORK</a> 本项目，或 <a href="http://weibo.com/211234880" target="_blank" title="姬小光，求关注^_^">@姬小光</a>
          <a href="https://diao.it">(diao.it)</a> 赐教。</div>
<div class="chapter" id="introduction">
  <h2 id="toc_introduction">引言</h2>
  <h3 id="toc_what-is-ember-js">Ember.js 是什么?</h3>
<p>Ember is a JavaScript framework for creating ambitious web applications
that eliminates boilerplate and provides a standard application
architecture.</p>

<p>Ember 是一个旨在创建非凡web应用的JavaScript框架，它消除了样板（boilerplate）并提供了标准的应用程序架构。</p>

<h4 id="toc_eliminate-boilerplate">消除样板</h4>

<p>There are some tasks that are common to every web application. For example,
taking data from the server, rendering it to the screen, then updating that
information when it changes.</p>

<p>每个web应用中都会有些常规的任务。例如，从服务器取数据、将数据渲染到屏幕、然后当数据变更时更新信息。</p>

<p>Since the tools provided to do this by the browser are quite primitive, you
end up writing the same code over and over. Ember.js provides tools that let
you focus on your app instead of writing the same code you've written a hundred
times.</p>

<p>由于浏览器能够提供的完成该任务的工具太过原始，致使你一遍一遍地书写相同的代码。Ember.js提供的工具可以让你专注于你的app，而不是重复地编写已经写过无数次的代码。</p>

<p>Because we've built dozens of applications ourselves, we've gone beyond the
obvious low-level event-driven abstractions, eliminating much of the
boilerplate associated with propagating changes throughout your application,
and especially into the DOM itself.</p>

<p>因为我们自己已经创建过数十个应用，我们已经远远超越了明显低级的事件驱动（event-driven）的抽象概念，消除了大量贯穿于应用当中的、与传播变化相关联的样板，尤其是DOM本身。</p>

<p>To help manage changes in the view, Ember.js comes with a templating engine
that will automatically update the DOM when the underlying objects change.</p>

<p>为了帮助你管理视图（view）中的变更，Ember.js内置了一个模板引擎，当底层的对象发生改变时它可以自动地更新DOM。</p>

<p>For a simple example, consider this template of a Person:</p>

<p>作为一个简单的例子，考虑这个Person的模板:</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{person.name}} is {{person.age}}.</pre></td>
</tr></tbody></table>
</div>

<p>As with any templating system, when the template is initially rendered, it
will reflect the current state of the person. To avoid boilerplate, though,
Ember.js will also update the DOM automatically for you if the person's name
or age changes.</p>

<p>与其他任何的模板系统类似，模板初始渲染时会影响到person的当前状态。然而，为了避免样板，当person的name更新时Ember.js也会为你自动更新DOM。</p>

<p>You specify your template once, and Ember.js makes sure it's always up to date.</p>

<p>一次性指定模板，Ember.js就会确保它实时更新。</p>

<h4 id="toc_provides-architecture">提供架构</h4>

<p>Since web applications evolved from web pages, which were nothing more than
static documents, browsers give you just enough rope to hang yourself with.</p>

<p>由于web应用是由web页面演变而来，其不过是静态文档而已，浏览器已赋予你充分的能力去做任何想做的事。</p>

<p>Ember makes it easy to divide your application into models, views, and controllers,
which improves testability, makes code more modular, and helps new developers
on the project quickly understand how everything fits together. The days of
callback spaghetti are over.</p>

<p>Ember可以让你很容易地将应用划分为模型（models），视图（views）和控制器（controllers），从而提高了可测性，使代码更加模块化，并且帮助项目中的新手快速理解各部分的结合原理。意面式的回调（callback spaghetti）时代结束了。（<a href="https://twitter.com/laserji" target="_blank">译者</a>注：<a href="http://en.wikipedia.org/wiki/Spaghetti_code" target="_blank">Spaghetti code</a>指具有复杂控制流程的代码。）</p>

<p>Ember also supplies built-in support for state management, so you'll have
a way to describe how your application moves through various nested states
(like signed-out, signed-in, viewing-post, and viewing-comment) out of the box.</p>

<p>Ember同样提供了内置的对状态管理的支持，从而可以描述你的应用程序在各种不同的嵌套状态（比如登入登出，浏览文章，查看评论）间的流转。</p>

<h3 id="toc_how-is-ember-js-different">Ember.js 有何不同？</h3>

<p>Traditional web applications make the user download a new page every time
they interact with the server. This means that every interaction is never faster
than the latency between you and the user, and usually slower. Using AJAX to
replace only parts of the page helps somewhat, but still requires a roundtrip to
your server every time your UI needs to update. And if multiple parts of the
page need to update all at once, most developers just resort to loading the page
over again, since keeping everything in sync is tricky.</p>

<p>传统的web应用迫使用户在每次与服务器交互时都得下载一个新页面。这意味着每次交互的时间不可能比你到用户之间的延时更快了，并且往往更慢。使用AJAX替换页面中的一些部分，在一定程度上起到了作用，但是在每次UI需要更新时，仍然需要一次到服务器的往返。并且如果页面中的许多部分需要同时更新，绝大部分开发者又会采取重新载入页面的方式了，因为若想保持每个部分都同步还真是个技术活。</p>

<p>Ember.js, like some other modern JavaScript frameworks, works a little differently.
Instead of the majority of your application's logic living on the server, an
Ember.js application downloads everything it needs to run in the initial page
load. That means that while your user is using your app, she never has to load
a new page and your UI responds quickly to their interaction.</p>

<p>与一些其他的现代JavaScript框架类似，Ember.js的工作方式略有不同。Ember.js应用会在页面初始载入时将所需全部加在，而不是将大多数应用逻辑存放于服务器端。这意味着当用户使用你的app时，她完全不必载入新页面，并且你的UI会快速响应交互操作。</p>

<p>One advantage of this architecture is that your web application uses the same
REST API as your native apps or third-party clients. Back-end developers can
focus on building a fast, reliable, and secure API server, and don't have to be
front-end experts, too.</p>

<p>这种架构的一个优点就是，你的web应用与本地（native）应用或者第三方客户端使用相同的REST API。后端开发者可以专注于构建一个快速，稳定，安全的API服务器，并且也不需要前端经验。</p>

<h3 id="toc_ember-js-at-a-glance">Ember.js 概览</h3>

<p>These are the three features that make Ember a joy to use:</p>

<p>三个法宝让你快乐地使用Ember：</p>

<ol>
<li>绑定（Bindings）</li>
<li>计算属性（Computed properties）</li>
<li>自动更新模板（Auto-updating templates）</li>
</ol>

<h4 id="toc_bindings">绑定</h4>

<p>Use bindings to keep properties between two different objects in sync. You just
declare a binding once, and Ember will make sure changes get propagated in either
direction.</p>

<p>使用绑定可以使两个不同对象的属性保持同步。你只需一次性声明绑定，然后Ember就会确保变更的双向传播。</p>

<p>Here's how you create a binding between two objects:</p>

<p>下面展示了如何在两个对象间建立绑定：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>MyApp.president = Ember.Object.create({
  <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Barack Obama</span><span class="delimiter">"</span></span>
});
MyApp.country = Ember.Object.create({
  <span class="comment">// Ending a property with 'Binding' tells Ember to</span>
  <span class="comment">// create a binding to the presidentName property.</span>
  <span class="key">presidentNameBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">MyApp.president.name</span><span class="delimiter">'</span></span>
});
<span class="comment">// Later, after Ember has resolved bindings...</span>
MyApp.country.get(<span class="string"><span class="delimiter">'</span><span class="content">presidentName</span><span class="delimiter">'</span></span>);
<span class="comment">// "Barack Obama"</span></pre></td>
</tr></tbody></table>
</div>

<p>Bindings allow you to architect your application using the MVC (Model-View-Controller)
pattern, then rest easy knowing that data will always flow correctly from layer to layer.</p>

<p>绑定允许你以MVC（Model-View-Controller）模式架构你的应用，然后即可高枕无忧了，数据将永远正确地在层与层之间流动。</p>

<h4 id="toc_computed-properties">计算属性</h4>

<p>Computed properties allow you to treat a function like a property:</p>

<p>计算属性允许你将函数视作属性：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>MyApp.president = Ember.Object.create({
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Barack</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Obama</span><span class="delimiter">"</span></span>,
  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
  <span class="comment">// Call this flag to mark the function as a property</span>
  }.property()
});
MyApp.president.get(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>);
<span class="comment">// "Barack Obama"</span></pre></td>
</tr></tbody></table>
</div>

<p>Computed properties are useful because they can work with bindings, just
like any other property.</p>

<p>计算属性非常有用，因为它可以像其他任何属性一样与绑定一起使用。</p>

<p>Many computed properties have dependencies on other properties. For example, in the above
example, the <code>fullName</code> property depends on <code>firstName</code> and <code>lastName</code> to determine its value.
You can tell Ember about these dependencies like this:</p>

<p>许多计算出的属性依赖于其他属性。例如，在上面的例子中，属性<code>fullName</code>依赖于<code>firstName</code>和<code>lastName</code>以确定其值。你可以像下面这样告诉Ember这些依赖关系：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>MyApp.president = Ember.Object.create({
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Barack</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Obama</span><span class="delimiter">"</span></span>,
  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
  <span class="comment">// Tell Ember that this computed property depends on firstName</span>
  <span class="comment">// and lastName</span>
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>)
});</pre></td>
</tr></tbody></table>
</div>

<p>Make sure you list these dependencies so Ember knows when to update bindings that connect
to a computed property.</p>

<p>要确保列出这些依赖，这样Ember才能知道何时更新与计算属性相关联的绑定。</p>

<h4 id="toc_auto-updating-templates">自动更新模板</h4>

<p>Ember uses Handlebars, a semantic templating library. To take data from your JavaScript application
and put it into the DOM, create a <code>&lt;script&gt;</code> tag and put it into your HTML, wherever you'd like the
value to appear:</p>

<p>Ember使用Handlebars,一个语义化的模板库，用以从你的JavaScript应用中获取数据并将其放进DOM，创建一个<code>&lt;script&gt;</code>标签，然后把它放到任何你希望展示数据的地方：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;script type="text/x-handlebars"&gt;
  The President of the United States is {{MyApp.president.fullName}}.
&lt;/script&gt;</pre></td>
</tr></tbody></table>
</div>

<p>Here's the best part: templates are bindings-aware. That means that if you ever change the value of
the property that you told us to display, we'll update it for you automatically. And because you've
specified dependencies, changes to <em>those</em> properties are reflected as well.</p>

<p>最棒的在这儿呢：模板是可感知绑定（bindings-aware）的。意思就是如果你改变了已经告知我们需要显示的属性值，我们会为你自动更新。并且由于你指定了依赖关系，对<em>那些</em>属性的更改也会体现出来。</p>

<p>Hopefully you can see how all three of these powerful tools work together: start with some primitive
properties, then start building up more sophisticated properties and their dependencies using computed
properties. Once you've described the data, you only have to say how it gets displayed once, and Ember
takes care of the rest. It doesn't matter how the underlying data changes, whether from an XHR request
or the user performing an action; your user interface always stays up-to-date. This eliminates entire
categories of edge cases that developers struggle with every day.</p>

  <p>希望你能看到这三个强大的工具是如何配合工作的：从一些原始的属性开始，然后使用计算属性构造一些更复杂的属性及其依赖关系。一旦你描述出数据，就只需要一次性指明数据是如何显示的，然后Ember即可帮你完成其余的任务。底层数据是如何改变的并不重要，不管是从XHR请求还是用户执行操作，你的用户界面总会保持实时更新。这消除了一大类开发人员每天为之挣扎的边缘情况（译者注：此句有点别扭，请意会）。</p>

</div>
<div class="chapter" id="getting_started">
  <h2 id="toc_getting-started">入门</h2>
<p>Depending on your needs, there are several ways to get started creating your
first Ember.js app.</p>

<p>根据你的需求，有几种方式可以创建你的第一个Ember.js app.</p>

<p>If your needs are simple or you're interested in just playing around, you can 
download the Ember.js Starter Kit. The Starter Kit is based on <a href="http://html5boilerplate.com/">HTML5 
Boilerplate</a> and does not require any build tools 
or other dependencies. To begin, download the Starter Kit and unzip it. You can 
edit the Handlebars templates directly inside the <code>index.html</code> file, and the 
Ember.js app itself lives in <code>javascripts/app.js</code>.</p>

    <p>如果你的需求较简单或者只是感兴趣随便玩玩，你可以下载Ember.js入门套件（Starter Kit）。该入门套件基于<a href="http://html5boilerplate.com/">HTML5 样板</a>，无需任何构建工具、没有其他依赖。首先，下载入门套件并解压缩。你可以直接在<code>index.html</code>文件中编辑Handlebars模板，而Ember.js app本身在<code>javascripts/app.js</code>中。</p>

<p>For larger apps, you may want to consider using Ruby on Rails. Rails helps you 
manage your source code and other assets, while also providing the REST API 
that your application will talk to.</p>

    <p>对于大型app，你可能会考虑使用Ruby on Rails，Rails会帮你管理源代码及其他资源，同时也提供了你的应用将会与之通讯的REST API。</p>

</div>
<div class="chapter" id="object_model">
  <h2 id="toc_the-ember-object-model">Ember对象模型</h2>
<p>Ember enhances the simple JavaScript object model to support bindings
and observers, as well as to support a more powerful mixin-based
approach to code sharing.</p>

  <p>Ember增强了简单的JavaScript对象模型，使之能够支持绑定和观察者，同时也支持一种更加强大的、基于混合的（mixin-based）代码共享途径。</p>

<p>At its most basic, you create a new Ember class by using the <code>extend</code>
method on <code>Ember.Object</code>.</p>

  <p>作为最基本的形式，你可以使用<code>Ember.Object</code>的<code>extend</code>方法创建一个新的Ember类。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="function">say</span>: <span class="keyword">function</span>(thing) {
    alert(thing);
 }
});</pre></td>
</tr></tbody></table>
</div>

<p>Once you have built a new class, you can create new instances of the
class by using the <code>create</code> method. Any properties defined on the class
will be available to instances.</p>

  <p>一旦你成功创建了一个新类，就可以使用<code>create</code>来创建类的实例了。类中定义的任何属性在实例中都是可用的。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> person = Person.create();
person.say(<span class="string"><span class="delimiter">"</span><span class="content">Hello</span><span class="delimiter">"</span></span>) <span class="comment">// alerts "Hello"</span></pre></td>
</tr></tbody></table>
</div>
<p>When creating an instance, you can also add additional properties to the
instance by passing in an object.</p>

  <p>创建实例时，也可以通过传入对象来为实例增添额外的属性。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> tom = Person.create({
  <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Tom Dale</span><span class="delimiter">"</span></span>,
  <span class="function">helloWorld</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.say(<span class="string"><span class="delimiter">"</span><span class="content">Hi my name is </span><span class="delimiter">"</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>));
  }
});
tom.helloWorld() <span class="comment">// alerts "Hi my name is Tom Dale"</span></pre></td>
</tr></tbody></table>
</div>
<p>Because of Ember's support for bindings and observers, you will always
access properties using the <code>get</code> method, and set properties using the
<code>set</code> method.</p>

  <p>由于Ember支持绑定和观察者，因此你可以随时通过<code>get</code>方法访问属性，也可以通过<code>set</code>方法设置属性。</p>

<p>When creating a new instance of an object, you can also override any
properties or methods defined on the class. For instance, in this case,
you could override the <code>say</code> method from the <code>Person</code> class.</p>

  <p>当创建一个对象的新的实例时，也可以覆写类中定义的任何属性和方法。在本例中，作为例子，你可以覆写从<code>Person</code>类继承的<code>say</code>方法。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> yehuda = Person.create({
  <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Yehuda Katz</span><span class="delimiter">"</span></span>,
  <span class="function">say</span>: <span class="keyword">function</span>(thing) {
    <span class="keyword">var</span> name = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>);
    <span class="local-variable">this</span>._super(name + <span class="string"><span class="delimiter">"</span><span class="content"> says: </span><span class="delimiter">"</span></span> + thing);
  }
});</pre></td>
</tr></tbody></table>
</div>
<p>You can use the <code>_super</code> method on the object (<code>super</code> is a reserved
word in JavaScript) to call the original method you overrode.</p>

  <p>你可以使用对象的<code>_super</code>方法（<code>super</code>是JavaScript中的保留字）来调用被你覆写的原始方法。</p>

<h3 id="toc_subclassing-classes">类的子类</h3>

<p>You can also create subclasses of classes you create by using the
<code>extend</code> method. In fact, when we created a new class above by calling
<code>extend</code> on <code>Ember.Object</code>, we were <strong>subclassing</strong> <code>Ember.Object</code>.</p>

  <p>你也可以使用<code>extend</code>方法为类创建子类。事实上，我们上面使用<code>Ember.Object</code>对象的<code>extend</code>方法创建新类时，即是创建了<code>Ember.Object</code>的<strong>子类</strong>。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> LoudPerson = Person.extend({
  <span class="function">say</span>: <span class="keyword">function</span>(thing) {
    <span class="local-variable">this</span>._super(thing.toUpperCase());
  }
});</pre></td>
</tr></tbody></table>
</div>
<p>When subclassing, you can use <code>this._super</code> to invoke methods you are
overriding.</p>

  <p>当创建子类时，你可以使用<code>this._super</code>来调用被你覆写的方法。</p>

<h3 id="toc_reopening-classes-and-instances">重新打开类和实例</h3>
<p>You don't need to define a class all at once. You can reopen a class and
define new properties using the <code>reopen</code> method.</p>

  <p>无需一次性将类定义完全，你可以使用<code>reopen</code>方法来重新打开（reopen）一个类并为其定义新的属性。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>Person.reopen({
  <span class="key">isPerson</span>: <span class="predefined-constant">true</span>
});
Person.create().get(<span class="string"><span class="delimiter">'</span><span class="content">isPerson</span><span class="delimiter">'</span></span>) <span class="comment">// true</span></pre></td>
</tr></tbody></table>
</div>
<p>When using <code>reopen</code>, you can also override existing methods and
call <code>this._super</code>.</p>

  <p>当使用<code>reopen</code>时，你也同样可以覆写已经存在的方法并调用<code>this._super</code>。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Person.reopen({
  <span class="comment">// override `say` to add an ! at the end</span>
  <span class="function">say</span>: <span class="keyword">function</span>(thing) {
    <span class="local-variable">this</span>._super(thing + <span class="string"><span class="delimiter">"</span><span class="content">!</span><span class="delimiter">"</span></span>);
  }
});</pre></td>
</tr></tbody></table>
</div>
<p>As you can see, <code>reopen</code> is used to add properties and methods to an instance.
But when you need to create class method or add the properties to the class itself you can use <code>reopenClass</code>.</p>

  <p>正如你所见，<code>reopen</code>是用来为实例添加属性和方法的。而当你需要创建类的方法或为类本身添加属性时，则可使用<code>reopenClass</code>。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Person.reopenClass({
  <span class="function">createMan</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> Person.create({<span class="key">isMan</span>: <span class="predefined-constant">true</span>})
  }
});
Person.createMan().get(<span class="string"><span class="delimiter">'</span><span class="content">isMan</span><span class="delimiter">'</span></span>) <span class="comment">// true</span></pre></td>
</tr></tbody></table>
</div><h3 id="toc_computed-properties-getters">计算属性 （Getters）</h3>

<p>Often, you will want a property that is computed based on other
properties. Ember's object model allows you to define computed
properties easily in a normal class definition.</p>

  <p>你可能经常需要一个基于其他属性计算而来的属性。Ember的对象模型可以使你很轻松地在常规的类定义中定义计算属性。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="comment">// these will be supplied by `create`</span>
  <span class="key">firstName</span>: <span class="predefined-constant">null</span>,
  <span class="key">lastName</span>: <span class="predefined-constant">null</span>,
  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> firstName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>);
    <span class="keyword">var</span> lastName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
   <span class="keyword">return</span> firstName + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + lastName;
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>)
});
<span class="keyword">var</span> tom = Person.create({
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Tom</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Dale</span><span class="delimiter">"</span></span>
});
tom.get(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>) <span class="comment">// "Tom Dale"</span></pre></td>
</tr></tbody></table>
</div>

<p>The <code>property</code> method defines the function as a computed property, and
defines its dependencies. Those dependencies will come into play later
when we discuss bindings and observers.</p>

  <p><code>property</code>方法将函数（function）定义为一个计算属性，并且定义了它的依赖关系。这些依赖在我们待会儿讨论绑定和观察者时会提到。</p>

<p>When subclassing a class or creating a new instance, you can override
any computed properties.</p>

  <p>当为类创建子类或者新的实例时，你可以覆写任何计算属性。</p>

<h3 id="toc_computed-properties-setters">计算属性 （Setters）</h3>

<p>You can also define what Ember should do when setting a computed
property. If you try to set a computed property, it will be invoked with
the key and value you want to set it to.</p>

  <p>你也可以定义当设置计算属性时Ember所执行的动作。当你尝试设置计算属性时，可以使用对应的名-值（key and value）对其进行设置。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="comment">// these will be supplied by `create`</span>
  <span class="key">firstName</span>: <span class="predefined-constant">null</span>,
  <span class="key">lastName</span>: <span class="predefined-constant">null</span>,
  <span class="function">fullName</span>: <span class="keyword">function</span>(key, value) {
    <span class="comment">// getter</span>
    <span class="keyword">if</span> (<span class="local-variable">arguments</span>.length === <span class="integer">1</span>) {
      <span class="keyword">var</span> firstName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>);
      <span class="keyword">var</span> lastName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
      <span class="keyword">return</span> firstName + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + lastName;
    <span class="comment">// setter</span>
    } <span class="keyword">else</span> {
      <span class="keyword">var</span> name = value.split(<span class="string"><span class="delimiter">"</span><span class="content"> </span><span class="delimiter">"</span></span>);
      <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, name[<span class="integer">0</span>]);
      <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>, name[<span class="integer">1</span>]);
      <span class="keyword">return</span> value;
    }
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>)
});
<span class="keyword">var</span> person = Person.create();
person.set(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">Peter Wagenet</span><span class="delimiter">"</span></span>);
person.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>) <span class="comment">// Peter</span>
person.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>) <span class="comment">// Wagenet</span></pre></td>
</tr></tbody></table>
</div>

<p>Ember will call the computed property for both setters and getters, and
you can check the number of arguments to determine whether it is being called
as a getter or a setter.</p>

  <p>对于setter和getter，Ember都会调用计算属性，你可以通过检查参数的个数来确定该计算属性究竟是被getter还是setter调用的。</p>

<h3 id="toc_observers">观察者</h3>

<p>Ember supports observing any property, including computed properties.
You can set up an observer on an object by using the <code>addObserver</code>
method.</p>

  <p>Ember支持观察任何属性，包括计算属性。你可以使用<code>addObserver</code>方法在某个对象上设置观察者。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="comment">// these will be supplied by `create`</span>
  <span class="key">firstName</span>: <span class="predefined-constant">null</span>,
  <span class="key">lastName</span>: <span class="predefined-constant">null</span>,
  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> firstName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>);
    <span class="keyword">var</span> lastName = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> firstName + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + lastName;
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>)
});
<span class="keyword">var</span> person = Person.create({
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Yehuda</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Katz</span><span class="delimiter">"</span></span>
});
person.addObserver(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() {
  <span class="comment">// deal with the change</span>
});
person.set(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">Brohuda</span><span class="delimiter">"</span></span>); <span class="comment">// observer will fire</span></pre></td>
</tr></tbody></table>
</div>

<p>Because the <code>fullName</code> computed property depends on <code>firstName</code>,
updating <code>firstName</code> will fire observers on <code>fullName</code> as well.</p>

  <p>由于<code>fullName</code>这个计算属性依赖于<code>firstName</code>，所以更新<code>firstName</code>也会触发<code>fullName</code>上的观察者。</p>

<p>Because observers are so common, Ember provides a way to define
observers inline in class definitions.</p>

  <p>由于观察者的应用非常普遍，Ember提供了一种能够在类定义的内部定义观察者的方式。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Person.reopen({
  <span class="function">fullNameChanged</span>: <span class="keyword">function</span>() {
    <span class="comment">// this is an inline version of .addObserver</span>
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>)
});</pre></td>
</tr></tbody></table>
</div>
<p>You can define inline observers by using the <code>Ember.observer</code> method if you
are using Ember without prototype extensions:</p>
<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Person.reopen({
  <span class="key">fullNameChanged</span>: Ember.observer(<span class="keyword">function</span>() {
    <span class="comment">// this is an inline version of .addObserver</span>
  }, <span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>)
});</pre></td>
</tr></tbody></table>
</div><h4 id="toc_changes-in-arrays">以数组形式的改变</h4>

<p>Often, you may have a computed property that relies on all of the items in an
array to determine its value. For example, you may want to count all of the
todo items in a controller to determine how many of them are completed.</p>

  <p>通常，你可能用到某个计算属性，它的值是由某个数组中的全部项来决定的。例如，你可能需要计算出某个控制器（controller）中全部的待办事项，以此来决定它们当中有多少是完成了的。</p>

<p>Here's what that computed property might look like:</p>

  <p>下面是这个计算属性可能的样子：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>App.todosController = Ember.Object.create({
  <span class="key">todos</span>: [
    Ember.Object.create({ <span class="key">isDone</span>: <span class="predefined-constant">false</span> })
  ],
  <span class="function">remaining</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> todos = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">todos</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> todos.filterProperty(<span class="string"><span class="delimiter">'</span><span class="content">isDone</span><span class="delimiter">'</span></span>, <span class="predefined-constant">false</span>).get(<span class="string"><span class="delimiter">'</span><span class="content">length</span><span class="delimiter">'</span></span>);
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">todos.@each.isDone</span><span class="delimiter">'</span></span>)
});</pre></td>
</tr></tbody></table>
</div>
<p>Note here that the dependent key (<code>todos.@each.isDone</code>) contains the special
key <code>@each</code>. This instructs Ember.js to update bindings and fire observers for
this computed property when one of the following four events occurs:</p>

  <p>注意这里的依赖键值（dependent key）（<code>todos.@each.isDone</code>）包含了特殊的键<code>@each</code>。这个是告诉Ember.js，当下面四个事件之一发生时，更新绑定并且触发这个计算属性的观察者。</p>

<ol>
<li>The <code>isDone</code> property of any of the objects in the <code>todos</code> array changes.</li>
<li>在<code>todos</code>中的任意对象的<code>isDone</code>属性发生改变时。</li>
<li>An item is added to the <code>todos</code> array.</li>
<li><code>todos</code>数组中增添了一项。</li>
<li>An item is removed from the <code>todos</code> array.</li>
<li><code>todos</code>数组中移除了一项。</li>
<li>The <code>todos</code> property of the controller is changed to a different array.</li>
<li>控制器的<code>todos</code>属性被替换为不同的数组。</li>
</ol>

<p>In the example above, the <code>remaining</code> count is <code>1</code>:</p>

<p>在上面的例子中，<code>remaining</code>的计算结果为<code>1</code>：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>App.todosController.get(<span class="string"><span class="delimiter">'</span><span class="content">remaining</span><span class="delimiter">'</span></span>);
<span class="comment">// 1</span></pre></td>
</tr></tbody></table>
</div>

<p>If we change the todo's <code>isDone</code> property, the <code>remaining</code> property is updated
automatically:</p>

  <p>如果我们改变待办事项的<code>isDone</code>属性，则<code>remaining</code>属性就会自动更新。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> todos = App.todosController.get(<span class="string"><span class="delimiter">'</span><span class="content">todos</span><span class="delimiter">'</span></span>);
<span class="keyword">var</span> todo = todos.objectAt(<span class="integer">0</span>);
todo.set(<span class="string"><span class="delimiter">'</span><span class="content">isDone</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>);
App.todosController.get(<span class="string"><span class="delimiter">'</span><span class="content">remaining</span><span class="delimiter">'</span></span>);
<span class="comment">// 0</span>
todo = Ember.Object.create({ <span class="key">isDone</span>: <span class="predefined-constant">false</span> });
todos.pushObject(todo);
App.todosController.get(<span class="string"><span class="delimiter">'</span><span class="content">remaining</span><span class="delimiter">'</span></span>);
<span class="comment">// 1</span></pre></td>
</tr></tbody></table>
</div>

  <h3 id="toc_bindings">绑定</h3>

<p>A binding creates a link between two properties such that when one changes, the
other one is updated to the new value automatically. Bindings can connect
properties on the same object, or across two different objects. Unlike most other
frameworks that include some sort of binding implementation, bindings in
Ember.js can be used with any object, not just between views and models.</p>

  <p>绑定在两个属性之间创建了一个连接，这样一个属性改变时另一个也可以随之自动更新到最新的值。绑定也可以连接同一对象内的属性，或者跨越两个不同的对象。与其他大部分框架所包含的绑定实现不同的是，Ember.js的绑定可以用在任何对象上，而不仅仅用在视图和模型之间。</p>

<p>The easiest way to create a two-way binding is by creating a new property
with the string <code>Binding</code> at the end, then specifying a path from the global scope:</p>

  <p>最简单的创建双向绑定的方法是，创建一个以<code>Binding</code>字串结尾的属性，然后指定一个相对于全局作用域（global scope）的路径：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>App.wife = Ember.Object.create({
  <span class="key">householdIncome</span>: <span class="integer">80000</span>
});
App.husband = Ember.Object.create({
  <span class="key">householdIncomeBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">App.wife.householdIncome</span><span class="delimiter">'</span></span>
});
App.husband.get(<span class="string"><span class="delimiter">'</span><span class="content">householdIncome</span><span class="delimiter">'</span></span>); <span class="comment">// 80000</span>
<span class="comment">// Someone gets raise.</span>
App.husband.set(<span class="string"><span class="delimiter">'</span><span class="content">householdIncome</span><span class="delimiter">'</span></span>, <span class="integer">90000</span>);
App.wife.get(<span class="string"><span class="delimiter">'</span><span class="content">householdIncome</span><span class="delimiter">'</span></span>); <span class="comment">// 90000</span></pre></td>
</tr></tbody></table>
</div>

<p>Note that bindings don't update immediately. Ember waits until all of your
application code has finished running before synchronizing changes, so you can
change a bound property as many times as you'd like without worrying about the
overhead of syncing bindings when values are transient.</p>

  <p>注意这个绑定不会立即更新，Ember会等待应用的所有代码运行完成之后再同步变更，因此你可以随意改变某个绑定的属性，而不用担心同步这些临时值所耗费的开销。</p>

<h4 id="toc_one-way-bindings">单向绑定</h4>

<p>A one-way binding only propagates changes in one direction. Usually, one-way
bindings are just a performance optimization and you can safely use
the more concise two-way binding syntax (as, of course, two-way bindings are
de facto one-way bindings if you only ever change one side).</p>

  <p>单向绑定只将变更单向传播。通常，单向绑定只是为了性能优化，你可以放心地使用更加简洁的双向绑定语法（当然，如果你总是只改变一边的话，那么双向绑定事实上也是单向绑定了）。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre>App.user = Ember.Object.create({
  <span class="key">fullName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Kara Gates</span><span class="delimiter">"</span></span>
});
App.userView = Ember.View.create({
  <span class="key">userNameBinding</span>: Ember.Binding.oneWay(<span class="string"><span class="delimiter">'</span><span class="content">App.user.fullName</span><span class="delimiter">'</span></span>)
});
<span class="comment">// Changing the name of the user object changes</span>
<span class="comment">// the value on the view.</span>
App.user.set(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">Krang Gates</span><span class="delimiter">"</span></span>);
<span class="comment">// App.userView.userName will become "Krang Gates"</span>
<span class="comment">// ...but changes to the view don't make it back to</span>
<span class="comment">// the object.</span>
App.userView.set(<span class="string"><span class="delimiter">'</span><span class="content">userName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">Truckasaurus Gates</span><span class="delimiter">"</span></span>);
App.user.get(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>); <span class="comment">// "Krang Gates"</span></pre></td>
</tr></tbody></table>
</div><h3 id="toc_what-do-i-use-when">何时用何物？</h3>

<p>Sometimes new users are confused about when to use computed properties,
bindings and observers. Here are some guidelines to help:</p>

  <p>有时新用户对于何时使用计算属性、绑定和观察者很困惑。下面是一些帮助提示：</p>

<ol>
<li><p>Use <em>computed properties</em> to build a new property by synthesizing other
properties. Computed properties should not contain application behavior, and
should generally not cause any side-effects when called. Except in rare cases,
multiple calls to the same computed property should always return the same
value (unless the properties it depends on have changed, of course.)</p></li>

<li><p>使用<em>计算属性</em>创建由其他属性综合决定的新属性。计算属性不应该包含应用的行为，而且当调用时不应有任何附加影响。除非在极少数情况下，多次调用相同的计算属性应该总是返回同样的值（当然，除了属性所依赖的属性值改变的情况。）</p></li>

<li><p><em>Observers</em> should contain behavior that reacts to changes in another
property. Observers are especially useful when you need to perform some
behavior after a binding has finished synchronizing.</p></li>

<li><p><em>观察者</em>应该包含反映其他属性变化的行为。当你需要在绑定完成同步之后执行一些行为的时候，观察者会非常有用。</p></li>

<li><p><em>Bindings</em> are most often used to ensure objects in two different layers
are always in sync. For example, you bind your views to your controller using
Handlebars. You may often bind between two objects in the same layer. For
example, you might have an <code>App.selectedContactController</code> that binds to the
<code>selectedContact</code> property of <code>App.contactsController</code>.</p></li>

<li><p><em>绑定</em>通常用在确保位于不同层的对象总能保持同步。例如，你使用Handlebars绑定了你的视图和控制器，你也可能经常需要绑定同一层的两个对象。例如，你可能有个<code>App.selectedContactController</code>需要绑定在<code>App.contactsController</code>的<code>selectedContact</code>属性上。</p></li>
</ol>

</div>
<div class="chapter" id="application">
  <h2 id="toc_creating-a-namespace">创建命名空间</h2>

<p>Every Ember app should have an instance of <code>Ember.Application</code>. This object
will serve as the globally-accessible namespace for all of the other classes
and instances in your app. Additionally, it sets up event listeners on the page
so that your views receive events when users interact with your user interface
(which you'll learn about later.)</p>

    <p>每个Ember app都应该有一个<code>Ember.Application</code>的实例。这个对象将会作为你的app中所有类和实例的全局可访问的命名空间（globally-accessible namespace）。此外，它也在页面上设置了事件监听器，确保当用户与你的用户界面进行交互时你的视图可以接收到事件（稍后你会了解到这些）。</p>

<p>Here's an example of an application:</p>

<p>这里是一个应用的例子：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>window.App = Ember.Application.create();</pre></td>
</tr></tbody></table>
</div>
<p>You can call your namespace whatever you'd like, but it must begin
with a capital letter in order for bindings to find it.</p>

    <p>你可以随意为你的命名空间命名，不过必须以大写字母开头，这样绑定才能找到它。</p>

<p>If you are embedding an Ember application into an existing site, you can
have event listeners set up for a specific element by providing a <code>rootElement</code> property:</p>

    <p>如果要将Ember应用嵌入到某个现存的网站中，可以通过提供<code>rootElement</code>属性来将某个特定的元素作为事件监听器。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>window.App = Ember.Application.create({
  <span class="key">rootElement</span>: <span class="string"><span class="delimiter">'</span><span class="content">#sidebar</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>
</div>

<div class="chapter" id="handlebars">
  <h2 id="toc_describing-your-ui-with-handlebars">使用Handlebars描述你的UI</h2><h3 id="toc_handlebars">Handlebars</h3>

<p>Ember comes bundled with <a href="http://www.handlebarsjs.com/">Handlebars</a>, a semantic templating language. These templates look like regular HTML, with embedded expressions.</p>

<p>Ember捆绑了<a href="http://www.handlebarsjs.com/">Handlebars</a>，一种语义化的模板语言。这些模板看上去像是普通的HTML嵌入了表达式。</p>

<p>You should store your Handlebars templates inside your application's HTML file. At runtime, Ember will compile these templates so they are available for you to use in your views.</p>

  <p>你应该把你的Handlebars模板存放在应用的HTML文件中。在运行时，Ember会编译这些模板，确保你可以在视图中使用它们。</p>

<p>To immediately insert a template into your document, place it inside a <code>&lt;script&gt;</code> tag within your <code>&lt;body&gt;</code> tag:</p>

  <p>要想快速向文档中插入模板，可以将模板放入一对<code>&lt;script&gt;</code>标签，并插入<code>&lt;body&gt;</code>标签中。</p>
<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>&lt;html&gt;
  &lt;body&gt;
    &lt;script type="text/x-handlebars"&gt;
      Hello, &lt;b&gt;{{MyApp.name}}&lt;/b&gt;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></td>
</tr></tbody></table>
</div>
<p>To make a template available to be used later, give the <code>&lt;script&gt;</code> tag a <code>data-template-name</code> attribute:</p>
<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>&lt;html&gt;
  &lt;head&gt;
    &lt;script type="text/x-handlebars" data-template-name="say-hello"&gt;
      Hello, &lt;b&gt;{{MyApp.name}}&lt;/b&gt;
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre></td>
</tr></tbody></table>
</div><h3 id="toc_ember-view">Ember.View</h3>
<p>You can use <code>Ember.View</code> to render a Handlebars template and insert it into the DOM.</p>

  <p>你可以使用<code>Ember.View</code>来渲染Handlebars模板并将其插入DOM。</p>

<p>To tell the view which template to use, set its <code>templateName</code> property. For example, if I had a <code>&lt;script&gt;</code> tag like this:</p>

  <p>要想让视图知道到底该使用哪个模板，可以设置它的<code>templateName</code>属性。例如，如果我有个这样的<code>&lt;script&gt;</code>标签：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>&lt;html&gt;
  &lt;head&gt;
    &lt;script type="text/x-handlebars" data-template-name="say-hello"&gt;
      Hello, &lt;b&gt;{{name}}&lt;/b&gt;
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre></td>
</tr></tbody></table>
</div>

<p>I would set the <code>templateName</code> property to <code>"say-hello"</code>.</p>

  <p>我会把<code>templateName</code>属性设置为<code>"say-hello"</code>。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> view = Ember.View.create({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">say-hello</span><span class="delimiter">'</span></span>,
  <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Bob</span><span class="delimiter">"</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>Note: For the remainder of the guide, the <code>templateName</code> property will be omitted from most examples. You can assume that if we show a code sample that includes an Ember.View and a Handlebars template, the view has been configured to display that template via the <code>templateName</code> property.</p>

  <p>注意：作为本指南的提示，大部分例子都会省略<code>templateName</code>属性。你可以假定当我们展示包含Ember.View和Handlebars模板的代码例子时，视图已经通过配置<code>templateName</code>属性来显示指定的模板了。</p>

<p>You can append views to the document by calling <code>appendTo</code>:</p>

  <p>你可以通过调用<code>appendTo</code>来像文档中追加视图：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>  view.appendTo(<span class="string"><span class="delimiter">'</span><span class="content">#container</span><span class="delimiter">'</span></span>);</pre></td>
</tr></tbody></table>
</div>

<p>As a shorthand, you can append a view to the document body by calling <code>append</code>:</p>

  <p>作为简写，你可以调用<code>append</code>向body中追加视图：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>  view.append();</pre></td>
</tr></tbody></table>
</div>

<p>To remove a view from the document, call <code>remove</code>:</p>

  <p>调用<code>remove</code>可以从文档中移除视图：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>  view.remove();</pre></td>
</tr></tbody></table>
</div><h3 id="toc_handlebars-basics">Handlebars基础</h3>

<p>As you've already seen, you can print the value of a property by enclosing it in a Handlebars expression, or a series of braces, like this:</p>

  <p>正如你所看到的，你可以使用Handlebars表达式、或者系列括号包含属性的值来将它打印出来，就像这样：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>My new car is {{color}}.</pre></td>
</tr></tbody></table>
</div>

<p>This will look up and print the View's <code>color</code> property. For example, if your view looks like this:</p>

  <p>这将会查找并打印视图的<code>color</code>属性。例如，如果你的视图看起来像这样：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.CarView = Ember.View.extend({
  <span class="key">color</span>: <span class="string"><span class="delimiter">'</span><span class="content">blue</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>Your view would appear in the browser like this:</p>

  <p>则你的视图在浏览器中会表现为：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>My new car is blue.</pre></td>
</tr></tbody></table>
</div>

<p>You can also specify global paths:</p>

  <p>你也可以指定全局路径：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>My new car is {{App.carController.color}}.</pre></td>
</tr></tbody></table>
</div>
<p>(Ember determines whether a path is global or relative to the view by checking whether the first letter is capitalized,
which is why your <code>Ember.Application</code> instance should start with a capital letter.)</p>

  <p>（Ember依靠首字母是否大写来确定某个路径是全局的还是相对于当前视图的，这也是为什么你的<code>Ember.Application</code>实例应该以大写字母开头的缘故。）</p>

<p>All of the features described in this guide are <strong>bindings aware</strong>. That means that if the values used by your templates ever change, your HTML will be updated automatically. It's like magic.</p>

  <p>本指南中描述的所有特性都是<strong>可感知绑定（bindings aware）</strong>的，这意味着模板所使用的值一旦发生变化，你的HTML就会自动更新，就像魔法一样神奇。</p>

<p>In order to know which part of your HTML to update when an underlying property changes, Handlebars will insert marker elements with a unique ID. If you look at your application while it's running, you might notice these extra elements:</p>

  <p>为了得知当底层的属性改变时HTML的哪个部分需要更新，Handlebars会插入带有惟一ID的标记元素。如果你在应用运行时查看，可能会注意到这些额外的元素：</p>
<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>My new car is
<span class="tag">&lt;script</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">metamorph-0-start</span><span class="delimiter">"</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">"</span><span class="content">text/x-placeholder</span><span class="delimiter">"</span></span><span class="tag">&gt;</span><span class="tag">&lt;/script&gt;</span>
blue
<span class="tag">&lt;script</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">metamorph-0-end</span><span class="delimiter">"</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">"</span><span class="content">text/x-placeholder</span><span class="delimiter">"</span></span><span class="tag">&gt;</span><span class="tag">&lt;/script&gt;</span>.</pre></td>
</tr></tbody></table>
</div>

<p>Because all Handlebars expressions are wrapped in these markers, make sure each HTML tag stays inside the same block. For example, you shouldn't do this:</p>

  <p>由于所有的Handlebars表达式都被包裹在这些标记中，所以要确保每个HTML标签都在相同的区块中。例如，你不应这么做：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>&lt;!-- Don't do it! --&gt;
&lt;div {{#if isUrgent}}class="urgent"{{/if}}&gt;</pre></td>
</tr></tbody></table>
</div>

<p>If you want to avoid your property output getting wrapped in these markers, use the <code>unbound</code> helper:</p>

  <p>如果你想避免输出的属性被包裹在这些标记中，可以使用<code>unbound</code>助手（helper）：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>My new car is {{unbound color}}.</pre></td>
</tr></tbody></table>
</div>
<p>Your output will be free of markers, but be careful, because the output won't be automatically updated!</p>

  <p>这样你的输出就不会有这些标记了，不过要小心，因为这些输出将不再自动更新！</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>My new car is blue.</pre></td>
</tr></tbody></table>
</div><h3 id="toc_if-else-and-unless">{{#if}}，{{else}}，和{{#unless}}</h3>

<p>Sometimes you may only want to display part of your template if a property
exists. For example, let's say we have a view with a <code>person</code> property that
contains an object with <code>firstName</code> and <code>lastName</code> fields:</p>

  <p>有时你可能只想在属性存在时显示部分的模板。例如，假设有个含有<code>person</code>属性的视图包含了一个拥有<code>firstName</code>和<code>lastName</code>字段的对象：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>App.SayHelloView = Ember.View.extend({
  <span class="key">person</span>: Ember.Object.create({
    <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Joy</span><span class="delimiter">"</span></span>,
    <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Clojure</span><span class="delimiter">"</span></span>
  })
});</pre></td>
</tr></tbody></table>
</div>

<p>In order to display part of the template only if the <code>person</code> object exists, we
can use the <code>{{#if}}</code> helper to conditionally render a block:</p>

  <p>为了只在<code>person</code>对象存在时显示部分模板，我们可以使用<code>{{#if}}</code>助手来依条件渲染某个区块：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>{{#if person}}
  Welcome back, &lt;b&gt;{{person.firstName}} {{person.lastName}}&lt;/b&gt;!
{{/if}}</pre></td>
</tr></tbody></table>
</div>

<p>Handlebars will not render the block if the argument passed evaluates to
<code>false</code>, <code>undefined</code>, <code>null</code> or <code>[]</code> (i.e., any "falsy" value).</p>

  <p>如果传入的参数为<code>false</code>、<code>undefined</code>、<code>null</code>或者<code>[]</code>（等等任何“假的”值）的话，Handlebars就不会渲染这个区块。</p>

<p>If the expression evaluates to falsy, we can also display an alternate template
using <code>{{else}}</code>:</p>

  <p>如果表达式执行的结果为假的（falsy），我们也可以使用<code>{{else}}</code>来显示一个替代的模板：</p>
<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>{{#if person}}
  Welcome back, &lt;b&gt;{{person.firstName}} {{person.lastName}}&lt;/b&gt;!
{{else}}
  Please log in.
{{/if}}</pre></td>
</tr></tbody></table>
</div>

<p>To only render a block if a value is falsy, use <code>{{#unless}}</code>:</p>

  <p>若想仅当某个值为假时才渲染区块，可以使用<code>{{#unless}}</code>：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>{{#unless hasPaid}}
  You owe: ${{total}}
{{/unless}}</pre></td>
</tr></tbody></table>
</div>

<p><code>{{#if}}</code> and <code>{{#unless}}</code> are examples of block expressions. These allow you
to invoke a helper with a portion of your template. Block expressions look like
normal expressions except that they contain a hash (#) before the helper name,
and require a closing expression.</p>

  <p><code>{{#if}}</code>和<code>{{#unless}}</code>是区块表达式（block expressions）的例子。这些允许你在模板的一部分上调用助手（helper）。区块表达式跟正常的表达式类似，只是他们在助手名前面包含一个哈希符（#），并且需要结束表达式。</p>

<h3 id="toc_with">{{#with}}</h3>

<p>Sometimes you may want to invoke a section of your template with a context
different than the Ember.View. For example, we can clean up the above template by
using the <code>{{#with}}</code> helper:</p>

  <p>有时你可能想在Ember.View之外的上下文中调用模板中的某一节。例如，我们可以使用<code>{{#with}}</code>助手清理上面的模板：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>{{#with person}}
  Welcome back, &lt;b&gt;{{firstName}} {{lastName}}&lt;/b&gt;!
{{/with}}</pre></td>
</tr></tbody></table>
</div>

<p><code>{{#with}}</code> changes the <em>context</em> of the block you pass to it. The context
is the object on which properties are looked up. By default, the context is the
Ember.View to which the template belongs.</p>

  <p><code>{{#with}}</code>改变了你所传入区块的<em>上下文（context）</em>。上下文即我们需要在其上查找属性的对象，默认的上下文为模板所属的Ember.View。</p>

<h3 id="toc_binding-element-attributes-with-bindattr">使用{{bindAttr}}绑定元素属性</h3>

<p>In addition to text, you may also want your templates to dictate the attributes
of your HTML elements. For example, imagine a view that contains a URL:</p>

  <p>除了文本外，你可能也希望模板可以掌控你的HTML元素。例如，想象一个包含URL的视图：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.LogoView = Ember.View.extend({
  <span class="key">logoUrl</span>: <span class="string"><span class="delimiter">'</span><span class="content">http://www.mycorp.com/images/logo.png</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>The best way to display the URL as an image in Handlebars is like this:</p>

  <p>使用Handlebars将URL显示为图片的最好方式为：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div id="logo"&gt;
  &lt;img {{bindAttr src="logoUrl"}} alt="Logo"&gt;
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>这会生成如下HTML:</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">logo</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;img</span> <span class="attribute-name">src</span>=<span class="string"><span class="delimiter">"</span><span class="content">http://www.mycorp.com/images/logo.png</span><span class="delimiter">"</span></span> <span class="attribute-name">alt</span>=<span class="string"><span class="delimiter">"</span><span class="content">Logo</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;/div&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>If you use <code>{{bindAttr}}</code> with a Boolean value, it will add or remove the specified attribute. For example, given this Ember view:</p>

  <p>如果你将<code>{{bindAttr}}</code>和布尔值一起使用，它将会添加或删除特定的属性。例如，给定如下的Ember视图：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.InputView = Ember.View.extend({
  <span class="key">isDisabled</span>: <span class="predefined-constant">true</span>
});</pre></td>
</tr></tbody></table>
</div>

<p>And this template:</p>

  <p>以及如下的模板：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>&lt;input type="checkbox" {{bindAttr disabled="isDisabled"}}&gt;</pre></td>
</tr></tbody></table>
</div>

<p>Handlebars will produce the following HTML element:</p>

  <p>Handlebars会产生如下的HTML元素：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;input</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">"</span><span class="content">checkbox</span><span class="delimiter">"</span></span> <span class="attribute-name">disabled</span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>
  <h3 id="toc_binding-class-names-with-bindattr">使用{{bindAttr}}绑定类名</h3>

<p>The <code>class</code> attribute can be bound like any other attribute, but it also has some additional special behavior. The default behavior works like you'd expect:</p>

  <p><code>class</code>属性可以像其他属性一样被绑定，不过它也有一些特殊行为。默认的行为如你所期待：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.AlertView = Ember.View.extend({
  <span class="key">priority</span>: <span class="string"><span class="delimiter">"</span><span class="content">p4</span><span class="delimiter">"</span></span>,
  <span class="key">isUrgent</span>: <span class="predefined-constant">true</span>
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="priority"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>This template will emit the following HTML:</p>

  <p>这个模板会生成如下的HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">p4</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
  Warning!
<span class="tag">&lt;/div&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>If the value to which you bind is a Boolean, however, the dasherized version of that property will be applied as a class:</p>

  <p>然而，如果你需要绑定的是个布尔值，则那个属性的将下划线替换为连字符后（译者注：dasherized，意为将所有的下划线“_”替换为连字符“-”的操作）的版本则会作为一个类：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="isUrgent"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>This emits the following HTML:</p>

  <p>这将产生如下的HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">is-urgent</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>
  Warning!
<span class="tag">&lt;/div&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>Unlike other attributes, you can also bind multiple classes:</p>

  <p>与其他属性不同的是，你也可以绑定多个类：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="isUrgent priority"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>You can also specify an alternate class name to use, instead of just
dasherizing.</p>

  <p>你也可以指定一个替代的类名，而不是简单地将下划线转换为连字符。</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="isUrgent:urgent"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>In this case, if the <code>isUrgent</code> property is true, the <code>urgent</code> class
will be added. If it is false, the <code>urgent</code> class will be removed.</p>

  <p>在这种情况下，如果<code>isUrgent</code>属性为true，则<code>urgent</code>类将会被添加。如果为false，则<code>urgent</code>类将被移除。</p>

<p>You can also specify a class name which shall be used when the property is <code>false</code>:</p>

  <p>你也可以指定一个当属性为<code>false</code>时所使用的类名：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="isEnabled:enabled:disabled"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>In this case, if the <code>isEnabled</code> property is true, the <code>enabled</code> class will be added. If the property is false, the class <code>disabled</code> will be added.</p>

  <p>在这种情况下，如果<code>isEnabled</code>属性为true，则<code>enabled</code>类将被添加。如果属性为false，则<code>disabled</code>类将被添加。</p>

<p>This syntax allows the shorthand for only adding a class when a property is <code>false</code>, so this:</p>

  <p>如果仅当某个属性为<code>false</code>时才添加类的话，那么这种语法还支持简写形式，即：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;div {{bindAttr class="isEnabled::disabled"}}&gt;
  Warning!
&lt;/div&gt;</pre></td>
</tr></tbody></table>
</div>

<p>Will add the class <code>disabled</code> when <code>isEnabled</code> is <code>false</code> and add no class if <code>isEnabled</code> is <code>true</code>.</p>

  <p>当<code>isEnabled</code>为<code>false</code>时会添加<code>disabled</code>类，而当<code>isEnabled</code>为<code>true</code>时则不会添加任何类。</p>

<h3 id="toc_handling-events-with-action">使用{{action}}处理事件</h3>

<p>Use the <code>{{action}}</code> helper to attach a handler in your view class to an event triggered on an element.</p>

  <p>使用<code>{{action}}</code>助手可以在你的视图类中将某个元素上触发的事件绑定到某个事件处理器（handler）上。</p>

<p>To attach an element's <code>click</code> event to the <code>edit()</code> handler in the current view:</p>

  <p>在当前视图中将一个元素的<code>click</code>事件绑定到<code>edit()</code>处理器上：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>&lt;a href="#" {{action "edit" on="click"}}&gt;Edit&lt;/a&gt;</pre></td>
</tr></tbody></table>
</div>

<p>Because the default event is <code>click</code>, this could be written more concisely as:</p>

  <p>由于缺省事件即为<code>click</code>，所以可以写得更简洁一些：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>&lt;a href="#" {{action "edit"}}&gt;Edit&lt;/a&gt;</pre></td>
</tr></tbody></table>
</div>

<p>Although the view containing the <code>{{action}}</code> helper will be targeted by default, it is possible to target a different view:</p>

  <p>尽管包含了<code>{{action}}</code>助手的视图会成为默认的事件目标，不过也可以将目标指向其他的视图：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>&lt;a href="#" {{action "edit" target="parentView"}}&gt;Edit&lt;/a&gt;</pre></td>
</tr></tbody></table>
</div>

<p>The action handler can optionally accept a jQuery event object, which will be extended to include <code>view</code> and <code>context</code> properties. These properties can be useful when targeting a different view with your action. For instance:</p>

  <p>这个动作处理器也可以选择性地接受一个jQuery事件对象，该对象将被扩展为包含<code>view</code>和<code>context</code>属性的对象。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>App.ListingView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">listing</span><span class="delimiter">'</span></span>,
  <span class="function">edit</span>: <span class="keyword">function</span>(event) {
    event.view.set(<span class="string"><span class="delimiter">'</span><span class="content">isEditing</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>);
  }
});</pre></td>
</tr></tbody></table>
</div>

<p>Any of the templates discussed above will produce an HTML element like this:</p>

  <p>上面讨论的任意一种模板都会生成如下HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;a</span> <span class="attribute-name">href</span>=<span class="string"><span class="delimiter">"</span><span class="content">#</span><span class="delimiter">"</span></span> <span class="attribute-name">data-ember-action</span>=<span class="string"><span class="delimiter">"</span><span class="content">3</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>Edit<span class="tag">&lt;/a&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>Ember will delegate the event you specified to your target view's handler based upon the internally assigned <code>data-ember-action</code> id.</p>

  <p>Ember会基于内部分配的<code>data-ember-action</code>id来代理你指定在目标视图处理器上的事件</p>

<h3 id="toc_building-a-view-hierarchy">创建视图的层次结构</h3>

<p>So far, we've discussed writing templates for a single view. However, as your application grows, you will often want to create a hierarchy of views to encapsulate different areas on the page. Each view is responsible for handling events and maintaining the properties needed to display it.</p>

  <p>目前为止，我们已经讨论过为单一的视图编写模板。然而，随着应用的扩大，你经常会需要创建分层次的视图来封装页面上的不同区域。每个视图分别负责处理事件和维护需要显示的属性。</p>
<h3 id="toc_view">{{view}}</h3>
<p>To add a child view to a parent, use the <code>{{view}}</code> helper, which takes a path to a view class.</p>

  <p>可以使用<code>{{view}}</code>助手来给一个父视图增添子视图，它接受一个视图类的路径参数。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="comment">// Define parent view</span>
App.UserView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">user</span><span class="delimiter">'</span></span>,
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Albert</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Hofmann</span><span class="delimiter">"</span></span>
});
<span class="comment">// Define child view</span>
App.InfoView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">info</span><span class="delimiter">'</span></span>,
  <span class="key">posts</span>: <span class="integer">25</span>,
  <span class="key">hobbies</span>: <span class="string"><span class="delimiter">"</span><span class="content">Riding bicycles</span><span class="delimiter">"</span></span>
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>User: {{firstName}} {{lastName}}
{{view App.InfoView}}</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>&lt;b&gt;Posts:&lt;/b&gt; {{posts}}
&lt;br&gt;
&lt;b&gt;Hobbies:&lt;/b&gt; {{hobbies}}</pre></td>
</tr></tbody></table>
</div>

<p>If we were to create an instance of <code>App.UserView</code> and render it, we would get
a DOM representation like this:</p>

  <p>如果我们想创建一个<code>App.UserView</code>的实例并渲染它，我们会得到如下的DOM表示方式：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>User: Albert Hofmann
<span class="tag">&lt;div&gt;</span>
  <span class="tag">&lt;b&gt;</span>Posts:<span class="tag">&lt;/b&gt;</span> 25
  <span class="tag">&lt;br&gt;</span>
  <span class="tag">&lt;b&gt;</span>Hobbies:<span class="tag">&lt;/b&gt;</span> Riding bicycles
<span class="tag">&lt;/div&gt;</span></pre></td>
</tr></tbody></table>
</div>
  <h4 id="toc_relative-paths">相对路径</h4>

<p>Instead of specifying an absolute path, you can also specify which view class
to use relative to the parent view. For example, we could nest the above view
hierarchy like this:</p>

  <p>相对于指定绝对路径，你也可以指定一个相对于父视图的路径。例如，我们可以将上面的视图层次修改如下：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>App.UserView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">user</span><span class="delimiter">'</span></span>,
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Albert</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Hofmann</span><span class="delimiter">"</span></span>,
  <span class="key">infoView</span>: Ember.View.extend({
    <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">info</span><span class="delimiter">'</span></span>,
    <span class="key">posts</span>: <span class="integer">25</span>,
    <span class="key">hobbies</span>: <span class="string"><span class="delimiter">"</span><span class="content">Riding bicycles</span><span class="delimiter">"</span></span>
  })
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>User: {{firstName}} {{lastName}}
{{view infoView}}</pre></td>
</tr></tbody></table>
</div>

<p>When nesting a view class like this, make sure to use a lowercase
letter, as Ember will interpret a property with a capital letter as a
global property.</p>

  <p>当以这种形式组织视图类时，要确保使用小写字母，因为Ember会把以大写字母开头的属性解释为全局属性。</p>

<h3 id="toc_setting-child-view-templates">设置子视图模板</h3>

<p>If you'd like to specify the template your child views use inline in
the main template, you can use the block form of the <code>{{view}}</code> helper.
We might rewrite the above example like this:</p>

  <p>如果你想在主模板中指定子视图类所使用的模板的话，可以使用<code>{{view}}</code>助手的区块形式。我们可以将上面的例子改写如下：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>App.UserView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">user</span><span class="delimiter">'</span></span>,
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Albert</span><span class="delimiter">"</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Hofmann</span><span class="delimiter">"</span></span>
});
App.InfoView = Ember.View.extend({
  <span class="key">posts</span>: <span class="integer">25</span>,
  <span class="key">hobbies</span>: <span class="string"><span class="delimiter">"</span><span class="content">Riding bicycles</span><span class="delimiter">"</span></span>
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>User: {{firstName}} {{lastName}}
{{#view App.InfoView}}
  &lt;b&gt;Posts:&lt;/b&gt; {{view.posts}}
  &lt;br&gt;
  &lt;b&gt;Hobbies:&lt;/b&gt; {{view.hobbies}}
{{/view}}</pre></td>
</tr></tbody></table>
</div>

<p>When you do this, it may be helpful to think of it as assigning views to
portions of the page. This allows you to encapsulate event handling for just
that part of the page.</p>

  <p>当你这么做的时候，把它想象成将视图应用到页面上的一部分的会更容易理解。这可以允许你只为页面中的那一部分封装事件处理器。</p>

<h3 id="toc_setting-up-bindings">设置绑定</h3>

<p>So far in our examples, we have been setting static values directly on the
views. But to best implement an MVC architecture, we should actually be binding
the properties of our views to the controller layer.</p>

  <p>目前在我们的例子中，我们已经在视图上直接设置了静态的值。不过作为最好的MVC架构实现，我们应该切实地将视图的属性绑定到控制器层才行。</p>

<p>Let's set up a controller to represent our user data:</p>

  <p>让我们设置一个可以代表我们的用户数据的控制器吧：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>App.userController = Ember.Object.create({
  <span class="key">content</span>: Ember.Object.create({
    <span class="key">firstName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Albert</span><span class="delimiter">"</span></span>,
    <span class="key">lastName</span>: <span class="string"><span class="delimiter">"</span><span class="content">Hofmann</span><span class="delimiter">"</span></span>,
    <span class="key">posts</span>: <span class="integer">25</span>,
    <span class="key">hobbies</span>: <span class="string"><span class="delimiter">"</span><span class="content">Riding bicycles</span><span class="delimiter">"</span></span>
  })
});</pre></td>
</tr></tbody></table>
</div>
<p>Now let's update <code>App.UserView</code> to bind to <code>App.userController</code>:</p>
<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.UserView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">user</span><span class="delimiter">'</span></span>,
  <span class="key">firstNameBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">App.userController.content.firstName</span><span class="delimiter">'</span></span>,
  <span class="key">lastNameBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">App.userController.content.lastName</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>When we only have a few bindings to configure, like with <code>App.UserView</code>, it is
sometimes useful to be able to declare those bindings in the template. You can
do that by passing additional arguments to the <code>{{#view}}</code> helper. If all
you're doing is configuring bindings, this often allows you to bypass having to
create a new subclass.</p>

  <p>当我们只有很少的绑定需要配置时，比如使用<code>App.UserView</code>时，有时能够在模板中声明这些绑定是很有用的。你可以通过给<code>{{#view}}</code>助手传入额外的参数来实现。如果你要做的只是配置绑定的话，这些特性通常可以使你避开创建新子类的工作。</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>User: {{firstName}} {{lastName}}
{{#view App.UserView postsBinding="App.userController.content.posts"
        hobbiesBinding="App.userController.content.hobbies"}}
  &lt;b&gt;Posts:&lt;/b&gt; {{view.posts}}
  &lt;br&gt;
  &lt;b&gt;Hobbies:&lt;/b&gt; {{view.hobbies}}
{{/view}}</pre></td>
</tr></tbody></table>
</div>

<p>NOTE: You can actually pass <strong>any</strong> property as a parameter to {{view}}, not
just bindings. However, if you are doing anything other than setting up
bindings, it is generally a good idea to create a new subclass.</p>

  <p>注意：实际上你可以将<strong>任何</strong>属性作为参数传给{{view}}，不仅仅是绑定。然而，如果你要做的不是设置绑定，那么最好创建一个新的子类。</p>

<h3 id="toc_modifying-a-view-s-html">修改视图的HTML</h3>

<p>When you append a view, it creates a new HTML element that holds its content.
If your view has any child views, they will also be displayed as child nodes
of the parent's HTML element.</p>

  <p>当追加视图时，会创建一个新的HTML元素来持有视图的内容。如果你的视图包含子视图，它们也会作为父HTML元素的子节点显示。</p>

<p>By default, new instances of <code>Ember.View</code> create a <code>&lt;div&gt;</code> element. You can
override this by passing a <code>tagName</code> parameter:</p>

  <p>缺省时，<code>Ember.View</code>的新实例会创建一个<code>&lt;div&gt;</code>元素。你可以通过传入<code>tagName</code>参数来覆盖这个缺省值。</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{view App.InfoView tagName="span"}}</pre></td>
</tr></tbody></table>
</div>

<p>You can also assign an ID attribute to the view's HTML element by passing an <code>id</code> parameter:</p>

  <p>你也可以通过传入<code>id</code>参数来为视图的HTML元素指定一个ID属性：</p>
<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{view App.InfoView id="info-view"}}</pre></td>
</tr></tbody></table>
</div>
<p>This makes it easy to style using CSS ID selectors:</p>

  <p>这可以使你很轻松地使用CSS ID选择器来应用样式：</p>

<div class="highlight css"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="comment">/** Give the view a red background. **/</span>
  <span class="constant">#info-view</span> {
    <span class="key">background-color</span>: <span class="value">red</span>;
  }</pre></td>
</tr></tbody></table>
</div>

<p>You can assign class names similarly:</p>

  <p>类似地，也可以指定类名：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{view App.InfoView class="info urgent"}}</pre></td>
</tr></tbody></table>
</div>

<p>You can bind class names to a property of the view by using <code>classBinding</code> instead of <code>class</code>. The same behavior as described in <code>bindAttr</code> applies:</p>

  <p>你可以使用<code>classBinding</code>而非<code>class</code>来将类名绑定到视图的某个属性上。上述同样的行为也适用于<code>bindAttr</code>：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.AlertView = Ember.View.extend({
  <span class="key">priority</span>: <span class="string"><span class="delimiter">"</span><span class="content">p4</span><span class="delimiter">"</span></span>,
  <span class="key">isUrgent</span>: <span class="predefined-constant">true</span>
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{view App.AlertView classBinding="isUrgent priority"}}</pre></td>
</tr></tbody></table>
</div>
<p>This yields a view wrapper that will look something like this:</p>

  <p>这将产生一个类似下面的视图容器：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">"</span><span class="content">sc420</span><span class="delimiter">"</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">sc-view is-urgent p4</span><span class="delimiter">"</span></span><span class="tag">&gt;</span><span class="tag">&lt;/div&gt;</span></pre></td>
</tr></tbody></table>
</div><h3 id="toc_displaying-a-list-of-items">显示一个列表的项目</h3>

<p>If you need to enumerate over a list of objects, use Handlebar's <code>{{#each}}</code> helper:</p>

  <p>如果你需要枚举一个对象列表，可以使用Handlebar的<code>{{#each}}</code>助手：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.PeopleView = Ember.View.extend({
  <span class="key">people</span>: [ { <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Yehuda</span><span class="delimiter">'</span></span> },
            { <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Tom</span><span class="delimiter">'</span></span> } ]
});</pre></td>
</tr></tbody></table>
</div><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>&lt;ul&gt;
  {{#each people}}
    &lt;li&gt;Hello, {{name}}!&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></td>
</tr></tbody></table>
</div>
<p>This will print a list like this:</p>

  <p>这将打印出如下的列表：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="tag">&lt;ul&gt;</span>
  <span class="tag">&lt;li&gt;</span>Hello, Yehuda!<span class="tag">&lt;/li&gt;</span>
  <span class="tag">&lt;li&gt;</span>Hello, Tom!<span class="tag">&lt;/li&gt;</span>
<span class="tag">&lt;/ul&gt;</span></pre></td>
</tr></tbody></table>
</div>
<p>If you want to create a view for every item in a list, just set it up as
follows:</p>

  <p>如果你想为列表中的每个项单独创建一个视图，只需进行如下设置：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>{{#each App.peopleController}}
  {{#view App.PersonView}}
    {{firstName}} {{lastName}}
  {{/view}}
{{/each}}</pre></td>
</tr></tbody></table>

</div><h3 id="toc_writing-custom-helpers">编写自定义助手</h3>

<p>Sometimes, you may use the same HTML in your application multiple times. In those case, you can register a custom helper that can be invoked from any Handlebars template.</p>

  <p>有时你可能在应用中会多次用到同样的HTML，在那种情况下，可以注册一个自定义的助手，它可以从任意的Handlebars模板中调用。</p>

<p>For example, imagine you are frequently wrapping certain values in a <code>&lt;span&gt;</code> tag with a custom class. You can register a helper from your JavaScript like this:</p>

  <p>例如，想象一下你会使用某个类频繁地将某个值包裹在<code>&lt;span&gt;</code>标签中</p>，就可以在你的JavaScript中注册一个助手，就像这样：

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>Handlebars.registerHelper(<span class="string"><span class="delimiter">'</span><span class="content">highlight</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>(property, options) {
  <span class="keyword">var</span> value = Ember.Handlebars.getPath(<span class="local-variable">this</span>, property, options);
  <span class="keyword">return</span> <span class="keyword">new</span> Handlebars.SafeString(<span class="string"><span class="delimiter">'</span><span class="content">&lt;span class="highlight"&gt;</span><span class="delimiter">'</span></span>+value+<span class="string"><span class="delimiter">'</span><span class="content">&lt;/span&gt;</span><span class="delimiter">'</span></span>);
});</pre></td>
</tr></tbody></table>
</div>
<p>If you return HTML from a helper, and you don't want it to be escaped,
make sure to return a new <code>SafeString</code>.</p>

  <p>若果想从一个助手返回HTML，又不希望它被转码，则要确保返回一个新的<code>安全字串（SafeString）</code>。</p>

<p>Anywhere in your Handlebars templates, you can now invoke this helper:</p>

  <p>在Handlebars模板的任何地方，都可以调用这个助手：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre>{{highlight name}}</pre></td>
</tr></tbody></table>
</div>
<p>and it will output the following:</p>
<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;span</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">highlight</span><span class="delimiter">"</span></span><span class="tag">&gt;</span>Peter<span class="tag">&lt;/span&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>NOTE: Parameters to helper functions are passed as names, not their current values. This allows you to optionally set up observers on the values. To get the current value of the parameter, use Ember.getPath, as shown above.</p>

  <p>注意：助手函数的参数是作为名称传递的，而不是它们当前的值。这可以允许你选择性地在值上设置观察者。要想获取参数的当前值，可以使用如上所示的Ember.getPath。</p>

<h3 id="toc_included-views">已包含的视图</h3>

<p>Ember comes pre-packaged with a set of views for building a few basic controls like text inputs, check boxes, and select lists.</p>

  <p>Ember预包装了一个视图的合集，用于构建一些基本的控件，比如文本输入框、单选框以及多选列表。</p>

<p>They are:</p>

  <p>它们是：</p>

<h4 id="toc_ember-checkbox">Ember.Checkbox</h4><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>    &lt;label&gt;
      {{view Ember.Checkbox checkedBinding="content.isDone"}}
      {{content.title}}
    &lt;/label&gt;</pre></td>
</tr></tbody></table>
</div><h4 id="toc_ember-textfield">Ember.TextField</h4><div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>    App.MyText = Ember.TextField.extend({
        <span class="key">formBlurredBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">App.adminController.formBlurred</span><span class="delimiter">'</span></span>,
        <span class="function">change</span>: <span class="keyword">function</span>(evt) {
          <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">formBlurred</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>);
        }
      });</pre></td>
</tr></tbody></table>
</div><h4 id="toc_ember-select">Ember.Select</h4><div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>    {{view Ember.Select viewName="select"
                          contentBinding="App.peopleController"
                          optionLabelPath="content.fullName"
                          optionValuePath="content.id"
                          prompt="Pick a person:"
                          selectionBinding="App.selectedPersonController.person"}}</pre></td>
</tr></tbody></table>
</div><h4 id="toc_ember-textarea">Ember.TextArea</h4><div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>    <span class="keyword">var</span> textArea = Ember.TextArea.create({
            <span class="key">valueBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">TestObject.value</span><span class="delimiter">'</span></span>
            });</pre></td>
</tr></tbody></table>
</div>

<p>If you would like to add one of these controls to your view, you are encouraged to extend from these controls.</p>

  <p>如果想添加这些控件之一到你的视图中，我们鼓励你从这些控件进行扩展。</p>

<p>Events do not bubble from a subview to a parent view so extending these views is the only way to capture those events.</p>

  <p>事件不会从子视图冒泡到父视图，因此扩展这些视图是捕获这些事件的惟一方法。</p>

<p>Example:</p>

  <p>例子：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>App.MyText = Ember.TextField.extend({
    <span class="key">formBlurredBinding</span>: <span class="string"><span class="delimiter">'</span><span class="content">App.adminController.formBlurred</span><span class="delimiter">'</span></span>,
    <span class="function">change</span>: <span class="keyword">function</span>(evt) {
      <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">formBlurred</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>);
    }
  });</pre></td>
</tr></tbody></table>
</div>

<p>You can then use this view as a sub view and capture the events.  In the following example, a change to the Name input would blurr the form and cause the save button to appear.</p>

  <p>然后即可将该视图作为子视图使用并捕获事件。在下面的例子中，Name输入的的改变会使表单失去焦点并显示保存按钮。</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre>&lt;script id="formDetail" data-template-name='formDetail' type="text/x-handlebars"&gt;
    &lt;form&gt;
        &lt;fieldset&gt;
           &lt;legend&gt;Info:&lt;/legend&gt;                 
                   {{view App.MyText name="Name" id="Name"  valueBinding="myObj.Name"}} 
                   &lt;label for="Name"&gt;Name&lt;/label&gt;&lt;br/&gt;
                   {{#if formBlurred}}
                    &lt;a href="#" {{action "syncData" on="click"}}&gt;Save&lt;/a&gt;
                    {{/if}}
        &lt;/fieldset&gt;
    &lt;/form&gt;
&lt;/script&gt;</pre></td>
</tr></tbody></table>
</div>
</div>
<div class="chapter" id="views">

  <h2 id="toc_views-in-depth">深入探讨视图</h2>

<p>Now that you're familiar with using Handlebars, let's go more in-depth on
how to both handle events, and customize views to your needs.</p>

  <p>现在你已经熟悉了Handlebars，让我们更加深入地探讨一下如何同时处理事件和根据你的需求自定义视图。</p>

<h3 id="toc_handling-events">处理事件</h3>

<p>Instead of having to register event listeners on elements you'd like to
respond to, simply implement the name of the event you want to respond to
as a method on your view.</p>

  <p>你只需简单地将事件名字作为你的视图的方法名实现即可，而无需为需要响应的每个元素注册事件监听器。</p>

<p>For example, imagine we have a template like this:</p>

  <p>例如，想象我们有如下模板：</p>

<div class="highlight handlebars"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>{{#view App.ClickableView}}
This is a clickable area!
{{/view}}</pre></td>
</tr></tbody></table>
</div>

<p>Let's implement App.ClickableView such that when it is
clicked, an alert is displayed:</p>

  <p>让我们来实现App.ClickableView，使之被点击时可以出现一个警告框：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.ClickableView = Ember.View.extend({
  <span class="function">click</span>: <span class="keyword">function</span>(evt) {
    alert(<span class="string"><span class="delimiter">"</span><span class="content">ClickableView was clicked!</span><span class="delimiter">"</span></span>);
  }
});</pre></td>
</tr></tbody></table>
</div>

<p>Events bubble up from the target view to each parent view in
succession, until the root view. These values are read-only. If you want to manually manage views in JavaScript (instead of creating them
using the {{view}} helper in Handlebars), see the Ember.ContainerView documentation below.</p>

  <p>事件会从目标视图陆续地冒泡到每一个父级视图，直到根（root）视图。这些值是只读的。如果你希望在JavaScript中手动管理视图（而不是使用Handlebars中的{{view}}助手创建），见下文的Ember.ContainerView文档。</p>

<h3 id="toc_manually-managed-views-with-ember-containerview">使用Ember.ContainerView手动管理视图</h3>

<p>Usually, views create their child views by using the <code>{{view}}</code> helper. Sometimes it is useful to manually manage a view's
child views. If you create an instance of <code>Ember.ContainerView</code>, the <code>childViews</code> array is editable. Views that you add
are rendered to the page, and views that you remove are removed from the DOM.</p>

  <p>通常，视图使用<code>{{view}}</code>助手来创建子视图。不过有时手动管理一个视图的子视图也非常有用。如果你创建了一个<code>Ember.ContainerView</code>的实例，则<code>childViews</code>数组是可编辑的。你添加的视图会渲染到页面中，而移除的视图会从DOM中移除。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> container = Ember.ContainerView.create();
container.append();
<span class="keyword">var</span> coolView = App.CoolView.create(),
    childViews = container.get(<span class="string"><span class="delimiter">'</span><span class="content">childViews</span><span class="delimiter">'</span></span>);
childViews.pushObject(coolView);</pre></td>
</tr></tbody></table>
</div>

<p>As a shorthand, you can specify the child views as properties and the child views as a list of keys. When the
container view is created, these views will be instantiated and added to the child views array:</p>

  <p>作为简写，你可以以属性的形式指定子视图，并将子视图作为一个键值列表。当容器视图被创建时，这些视图会被初始化并添加到子视图数组中：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> container = Ember.ContainerView.create({
  <span class="key">childViews</span>: [<span class="string"><span class="delimiter">'</span><span class="content">firstView</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">secondView</span><span class="delimiter">'</span></span>],
  <span class="key">firstView</span>: App.FirstView,
  <span class="key">secondView</span>: App.SecondView
});</pre></td>
</tr></tbody></table>
</div>
  <h3 id="toc_render-pipeline">渲染管线（Render Pipeline）</h3>

<p>Before your views are turned into DOM elements, they first exist as a string representation. As views render, they turn
each of their child views into strings and concatenate them together.</p>

  <p>在你的视图转换为DOM元素之前，它们起初是作为字符串形式存在的。随着视图的渲染，它们把每个子视图转换为字符串并将它们连接在一起。</p>

<p>If you'd like to use something other than Handlebars, you can override a view's <code>render</code> method to generate a custom
string of HTML.</p>

  <p>如果你不想使用Handlebars，可以覆写一个视图的<code>render</code>方法来生成自定义的HTML字串。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.CoolView = Ember.View.create({
  <span class="function">render</span>: <span class="keyword">function</span>(buffer) {
    buffer.push(<span class="string"><span class="delimiter">"</span><span class="content">&lt;b&gt;This view is so cool!&lt;/b&gt;</span><span class="delimiter">"</span></span>);
  }
});</pre></td>
</tr></tbody></table>
</div>

<p>This makes it easy to support template engines other than Handlebars; though do note that if you override rendering,
values will not update automatically. Any updates will be your responsibility.</p>

  <p>这使得支持Handlebars之外的模板变得非常容易，然而需要注意的是，如果覆写了渲染，这些值就不会自动更新了。任何的更新都将是你的责任了。</p>

<h3 id="toc_customizing-the-html-element">自定义HTML元素</h3>

<p>A view is represented by a single DOM element on the page. You can change what kind of element is created by
changing the <code>tagName</code> property.</p>

  <p>一个视图代表页面上的一个单独的DOM元素。你可以通过修改<code>tagName</code>属性来改变创建的元素类型。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">tagName</span>: <span class="string"><span class="delimiter">'</span><span class="content">span</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>You can also specify which class names are applied to the view by setting its <code>classNames</code> property to an array of strings:</p>

  <p>你也可以通过将视图的<code>classNames</code>属性设置为字符串数组来指定视图所应用的类名。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNames</span>: [<span class="string"><span class="delimiter">'</span><span class="content">my-view</span><span class="delimiter">'</span></span>]
});</pre></td>
</tr></tbody></table>
</div>

<p>If you want class names to be determined by the state of properties on the view, you can use class name bindings. If you bind to
a Boolean property, the class name will be added or removed depending on the value:</p>

  <p>如果你希望类名由视图上属性的状态来决定的话，可以使用类名绑定。如果你绑定了一个布尔值的属性，则属性值将决定类的添加和删除：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNameBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">isUrgent</span><span class="delimiter">'</span></span>],
  <span class="key">isUrgent</span>: <span class="predefined-constant">true</span>
});</pre></td>
</tr></tbody></table>
</div>

<p>This would render a view like this:</p>

  <p>这将渲染出如下视图：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view is-urgent</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>If isUrgent is changed to false, then the <code>is-urgent</code> class name will be removed.</p>

  <p>如果isUrgent被改为false，则<code>is-urgent</code>类名将被移除。</p>

<p>By default, the name of the Boolean property is dasherized. You can customize the class name
applied by delimiting it with a colon:</p>

  <p>默认情况下，布尔值属性的名称已经被dasherized（译者注：上文有提到，是将下划线替换为连字符的操作）。你可以使用冒号分隔来自定义所应用的类名。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNameBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">isUrgent:urgent</span><span class="delimiter">'</span></span>],
  <span class="key">isUrgent</span>: <span class="predefined-constant">true</span>
});</pre></td>
</tr></tbody></table>
</div>

<p>This would render this HTML:</p>

  <p>这将渲染出如下HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view urgent</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p>

  <p>除了在值为<code>true</code>的时候自定义类名，你也可以指定一个当值为<code>false</code>时所使用的类名：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNameBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">isEnabled:enabled:disabled</span><span class="delimiter">'</span></span>],
  <span class="key">isEnabled</span>: <span class="predefined-constant">false</span>
});</pre></td>
</tr></tbody></table>
</div>

<p>This would render this HTML:</p>

  <p>这将渲染出如下HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view disabled</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>You can also specify to only add a class when the property is <code>false</code> by declaring <code>classNameBindings</code> like this:</p>

  <p>你也可以通过声明<code>classNameBindings</code>来指定当属性为<code>false</code>时只添加一个类：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNameBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">isEnabled::disabled</span><span class="delimiter">'</span></span>],
  <span class="key">isEnabled</span>: <span class="predefined-constant">false</span>
});</pre></td>
</tr></tbody></table>
</div>

<p>This would render this HTML:</p>

  <p>这将渲染出如下HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view disabled</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p>

  <p>如果<code>isEnabled</code>属性被设置为<code>true</code>，则不会添加任何类名：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>

<p>If the bound value is a string, that value will be added as a class name without
modification:</p>

  <p>如果绑定的值为字符串，则这个值会不加修改地作为类名添加：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">classNameBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">priority</span><span class="delimiter">'</span></span>],
  <span class="key">priority</span>: <span class="string"><span class="delimiter">'</span><span class="content">highestPriority</span><span class="delimiter">'</span></span>
});</pre></td>
</tr></tbody></table>
</div>

<p>This would render this HTML:</p>

  <p>这将渲染出如下HTML：</p>

<div class="highlight html"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre></pre></td>
  <td class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">"</span><span class="content">ember-view highestPriority</span><span class="delimiter">"</span></span><span class="tag">&gt;</span></pre></td>
</tr></tbody></table>
</div>
  <h3 id="toc_attribute-bindings-on-a-view">视图的属性绑定</h3>

<p>You can bind attributes to the DOM element that represents a view by using <code>attributeBindings</code>:</p>

  <p>你可以使用<code>attributeBindings</code>将属性绑定到代表某个视图的DOM元素上：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.MyView = Ember.View.extend({
  <span class="key">tagName</span>: <span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>,
  <span class="key">attributeBindings</span>: [<span class="string"><span class="delimiter">'</span><span class="content">href</span><span class="delimiter">'</span></span>],
  <span class="key">href</span>: <span class="string"><span class="delimiter">"</span><span class="content">http://emberjs.com</span><span class="delimiter">"</span></span>
});</pre></td>
</tr></tbody></table>
</div>
</div>
<div class="chapter" id="enumerables">
  <h2 id="toc_the-ember-enumerable-api">Ember枚举（Enumerable）API</h2><h3 id="toc_what-are-enumerables">什么是枚举类型？</h3>

<p>In Ember, an Enumerable is any object that contains a number of child objects, and which allows you to work with those children using the Enumerable interface. The most basic Enumerable is the built-in JavaScript Array.</p>

  <p>在Ember中，一个可枚举类型（译者注：Enumerable的原意是可枚举的，但此处是作为名词存在，暂译为可枚举类型）是指任何包含一系列子对象的类型，并且允许你使用枚举接口操作这些子对象。最基本的可枚举类型是JavaScript内置的数组。</p>

<p>For instance, all Enumerables support the standard <code>forEach</code> method:</p>

  <p>例如，所有的可枚举类型都支持标准的<code>forEach</code>方法：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>[<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>].forEach(<span class="keyword">function</span>(item) {
  console.log(item);
});</pre></td>
</tr></tbody></table>
</div>

<p>In general, Enumerable methods, like <code>forEach</code>, take an optional second parameter, which will become the value of <code>this</code> in the callback function:</p>

  <p>总体来说，像<code>forEach</code>这样的枚举方法，接受可选的第二个参数，该参数将作为回调函数中<code>this</code>的值：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> array = [<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>];
array.forEach(<span class="keyword">function</span>(item) {
  console.log(item, <span class="local-variable">this</span>.indexOf(item));
}, array)</pre></td>
</tr></tbody></table>
</div>

<p>Among other reasons, you will find this useful when using another Enumerable method as a callback to <code>forEach</code>:</p>

  <p>除去其他原因，你会发现这在使用其他枚举方法作为<code>forEach</code>的回调函数时会非常有用：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> array = [<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>];
array.forEach(array.removeObject, array);</pre></td>
</tr></tbody></table>
</div>

<p>NOTE: This second parameter helps work around a limitation of JavaScript which sets the value of <code>this</code> to <code>window</code> in methods used this way.</p>

  <p>注意：这第二个参数可以帮助解决JavaScript一个局限性，即当我们这样调用方法时，<code>this</code>的值会被设置成<code>window</code>。</p>

<h3 id="toc_enumerables-in-ember">Ember中的枚举类型</h3>

<p>In general, Ember objects that represent lists implement the Enumerable interface. Some examples:</p>

  <p>总起来说，Ember中代表列表的对象实现了枚举接口。一些例子：</p>

<ul>
<li><em>Array</em>: Ember extends the native JavaScript Array with the Enumerable interface.</li>
<li><em>Array</em>: Ember为原生的JavaScript数组扩展了枚举接口。</li>
<li><em>ArrayProxy</em>: A construct that wraps a native Array and adds additional functionality for the view layer.</li>
<li><em>ArrayProxy</em>: 一个封装了原生数组并为视图层添加了额外功能的结构体（construct）。</li>
<li><em>Set</em>: An object that can quickly answer whether it includes an object.</li>
<li><em>Set</em>: 一个可以快速确定其是否包含一个对象的对象。</li>
</ul>
<h3 id="toc_the-enumerable-interface">枚举接口</h3><h4 id="toc_parameters">参数</h4>
<p>The callbacks to Enumerable methods take three arguments:</p>

  <p>枚举方法的回调函数接受三个参数：</p>

<ul>
<li><em>item</em>: the item for the current iteration.</li>
<li><em>item</em>: 当前迭代项。</li>
<li><em>index</em>: an Integer, counting up from 0.</li>
<li><em>index</em>: 一个从0开始累加的整数。</li>
<li><em>self</em>: the Enumerable itself.</li>
<li><em>self</em>: 可枚举类型本身。</li>
</ul>
<h4 id="toc_enumeration">枚举</h4>
<p>To enumerate all the values of an enumerable object, use the <code>forEach</code> method:</p>

  <p>可以使用<code>forEach</code>方法来枚举一个可枚举对象的所有值：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>enumerable.forEach(<span class="keyword">function</span>(item, index, self) {
  console.log(item);
});</pre></td>
</tr></tbody></table>
</div>

<p>To invoke some method on each element of an enumerable object, use the <code>invoke</code> method:</p>

  <p>若想在枚举对象的每个元素上调用一些方法，可以使用<code>invoke</code>方法：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="function">sayHello</span>: <span class="keyword">function</span>() {
    console.log(<span class="string"><span class="delimiter">"</span><span class="content">Hello from </span><span class="delimiter">"</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>));
  }
});
<span class="keyword">var</span> people = [
  Person.create({ <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Juan</span><span class="delimiter">"</span></span> }),
  Person.create({ <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Charles</span><span class="delimiter">"</span></span> }),
  Person.create({ <span class="key">name</span>: <span class="string"><span class="delimiter">"</span><span class="content">Majd</span><span class="delimiter">"</span></span> })
]
people.invoke(<span class="string"><span class="delimiter">'</span><span class="content">sayHello</span><span class="delimiter">'</span></span>);
<span class="comment">// Hello from Juan</span>
<span class="comment">// Hello from Charles</span>
<span class="comment">// Hello from Majd</span></pre></td>
</tr></tbody></table>
</div><h4 id="toc_first-and-last">头尾对象</h4>
<p>You can get the first or last object from an Enumerable by getting <code>firstObject</code> or <code>lastObject</code>.</p>

  <p>你可以通过<code>firstObject</code>或者<code>lastObject</code>来获取一个可枚举类型的第一个或者最后一个对象。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>[<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>].get(<span class="string"><span class="delimiter">'</span><span class="content">firstObject</span><span class="delimiter">'</span></span>) <span class="comment">// 1</span>
[<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>].get(<span class="string"><span class="delimiter">'</span><span class="content">lastObject</span><span class="delimiter">'</span></span>)  <span class="comment">// 3</span></pre></td>
</tr></tbody></table>
</div><h4 id="toc_converting-to-array">转换为数组</h4>

<p>This one is simple. To convert an Enumerable into an Array, simply call its <code>toArray</code> method.</p>

  <p>这个很简单。要想将一个可枚举类型转换为数组，只需调用它的<code>toArray</code>方法即可。</p>

<h4 id="toc_transforming">变换</h4>

<p>You can transform an Enumerable into a derived Array by using the <code>map</code> method:</p>

  <p>你可以使用<code>map</code>方法将一个可枚举类型变换为一个派生的数组：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>[<span class="string"><span class="delimiter">'</span><span class="content">Goodbye</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cruel</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">world</span><span class="delimiter">'</span></span>].map(<span class="keyword">function</span>(item, index, self) {
  <span class="keyword">return</span> item + <span class="string"><span class="delimiter">"</span><span class="content">!</span><span class="delimiter">"</span></span>;
});
<span class="comment">// returns ["Goodbye!", "cruel!", "world!"]</span></pre></td>
</tr></tbody></table>
</div><h4 id="toc_setting-and-getting-on-each-object">每个对象上的获取或设置</h4>

<p>A very common use of <code>forEach</code> and <code>map</code> is to get (or set) a property on each element. You can use the <code>getEach</code> and <code>setEach</code> methods to accomplish these goals.</p>

  <p><code>forEach</code>和<code>map</code>的一个通常用法就是在每个元素上获取（或设置）一个属性。你可以使用<code>getEach</code>和<code>setEach</code>方法来完成这个目标。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> arr = [Ember.Object.create(), Ember.Object.create()];
<span class="comment">// we now have an Array containing two Ember.Objects</span>
arr.setEach(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">unknown</span><span class="delimiter">'</span></span>);
arr.getEach(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>) <span class="comment">// ['unknown', 'unknown']</span></pre></td>
</tr></tbody></table>
</div><h4 id="toc_filtering">过滤</h4>
<p>Another common task to perform on an Enumerable is to take the Enumerable as input, and return an Array after filtering it based on some criteria.</p>

  <p>在枚举类型上经常会用到的另外一个常规任务就是将枚举类型作为输入，并基于某些标准过滤后返回一个数组。</p>

<p>For arbitrary filtering, use the (you guessed it) <code>filter</code> method. The filter method expects the callback to return <code>true</code> if Ember should include it in the final Array, and <code>false</code> or <code>undefined</code> if Ember should not.</p>

  <p>对于任意的过滤，使用（你已经猜到了）<code>filter</code>方法。如果Ember在最终的数组中应该包含该项的话，则filter方法期待回调函数返回<code>true</code>。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> arr = [<span class="integer">1</span>,<span class="integer">2</span>,<span class="integer">3</span>,<span class="integer">4</span>,<span class="integer">5</span>];
arr.filter(<span class="keyword">function</span>(item, index, self) {
  <span class="keyword">if</span> (item &lt; <span class="integer">4</span>) { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }
})
<span class="comment">// returns [1,2,3]</span></pre></td>
</tr></tbody></table>
</div>

<p>When working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The <code>filterProperty</code> method provides a shortcut.</p>

  <p>当操作一个Ember对象的集合时，你经常会需要基于某些属性的值来过滤一组对象。<code>filterProperty</code>方法提供了一种快捷方式。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>Todo = Ember.Object.extend({
  <span class="key">title</span>: <span class="predefined-constant">null</span>,
  <span class="key">isDone</span>: <span class="predefined-constant">false</span>
});
todos = [
  Todo.create({ <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">Write code</span><span class="delimiter">'</span></span>, <span class="key">isDone</span>: <span class="predefined-constant">true</span> }),
  Todo.create({ <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">Go to sleep</span><span class="delimiter">'</span></span> })
];
todos.filterProperty(<span class="string"><span class="delimiter">'</span><span class="content">isDone</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>);
<span class="comment">// returns an Array containing just the first item</span></pre></td>
</tr></tbody></table>
</div>

<p>If you want to return just the first matched value, rather than an Array containing all of the matched values, you can use <code>find</code> and <code>findProperty</code>, which work just like <code>filter</code> and <code>filterProperty</code>, but return only one item.</p>

  <p>如果你只希望返回第一个匹配的值，而不是包含所有匹配值的数组，则可使用<code>find</code>和<code>findProperty</code>，用起来跟<code>filter</code>和<code>filterProperty</code>一样，只是仅返回一项。</p>
<h4 id="toc_aggregate-information-all-or-any">汇总信息（全部或任意的）</h4>
<p>If you want to find out whether every item in an Enumerable matches some condition, you can use the <code>every</code> method:</p>

  <p>如果你想知道是否一个枚举类型中的每一项都可以匹配某些条件的话，可以使用<code>every</code>方法：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre>Person = Ember.Object.extend({
  <span class="key">name</span>: <span class="predefined-constant">null</span>,
  <span class="key">isHappy</span>: <span class="predefined-constant">false</span>
});
<span class="keyword">var</span> people = [
  Person.create({ <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Yehuda</span><span class="delimiter">'</span></span>, <span class="key">isHappy</span>: <span class="predefined-constant">true</span> }),
  Person.create({ <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Majd</span><span class="delimiter">'</span></span>, <span class="key">isHappy</span>: <span class="predefined-constant">false</span> })
];
people.every(<span class="keyword">function</span>(person, index, self) {
  <span class="keyword">if</span>(person.get(<span class="string"><span class="delimiter">'</span><span class="content">isHappy</span><span class="delimiter">'</span></span>)) { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }
});
<span class="comment">// returns false</span></pre></td>
</tr></tbody></table>
</div>

<p>If you want to find out whether at least one item in an Enumerable matches some conditions, you can use the <code>some</code> method:</p>

  <p>如果你想知道在一个枚举类型中是否至少有一项可以匹配某些条件的话，可以使用<code>some</code>方法：</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>people.some(<span class="keyword">function</span>(person, index, self) {
  <span class="keyword">if</span>(person.get(<span class="string"><span class="delimiter">'</span><span class="content">isHappy</span><span class="delimiter">'</span></span>)) { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }
});
<span class="comment">// returns true</span></pre></td>
</tr></tbody></table>
</div>

<p>Just like the filtering methods, the <code>every</code> and <code>some</code> methods have analogous <code>everyProperty</code> and <code>someProperty</code> methods.</p>

  <p>与过滤方法类似，<code>every</code>和<code>some</code>方法也有类似的<code>everyProperty</code>和<code>someProperty</code>方法。</p>

<div class="highlight javascript"><div class="ribbon"></div><table class="CodeRay"><tbody><tr>
  <td class="line-numbers" title="double click to toggle" onDblClick="with (this.firstChild.style) { display = (display == &#39;&#39;) ? &#39;none&#39; : &#39;&#39; }"><pre>1
2
</pre></td>
  <td class="code"><pre>people.everyProperty(<span class="string"><span class="delimiter">'</span><span class="content">isHappy</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>) <span class="comment">// false</span>
people.someProperty(<span class="string"><span class="delimiter">'</span><span class="content">isHappy</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>)  <span class="comment">// true</span></pre></td>
</tr></tbody></table>
</div>
</div>

      </div>
    </div>

    <div id="footer">
      <div class="info">
        <div class="links"><a href="http://twitter.com/emberjs">Twitter</a> • <a href="https://github.com/emberjs/ember.js">GitHub</a></div>
        <div class="copyright">Copyright 2012 <a href="http://tilde.io/">Tilde Inc.</a></div>
        <div class="credit">Design by <a href="http://www.heropixel.com/">HeroPixel</a></div>
      </div>
    </div>
  


</body></html>
